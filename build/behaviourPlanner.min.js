//BehaviourPlanner manages the core logic of Behaviour Graph

//EntitiesManager does the natural language processing for the ParseCompare logic (extracts tags)

/**
 * Dependencies:
 *  Compromise Cool
 */


 (function _entities(global)
 {
    const nlp = require('compromise')
    nlp.extend(require('compromise-numbers'))
    nlp.extend(require('compromise-dates'))
    class EntitiesManager{
        constructor(){

        this.name = "EntitiesManager";
        this.properties_log = {};
        this.entities= [];
        this.customEntities = {};
       
        }
       
        initData(){
            for(var i in nlp.world().tags)
                this.entities.push("#"+i);
        }

        getEntity(text, entity)
        {
            if(entity == "#Value")
            {
                text = text.toLowerCase();
            }
            
            if(entity == "#PhoneNumber" || entity == "#NumericValue")
            {
                //text = text.replaceAll(" ", "");
                text = text.replaceAll("-", "");
                var text_split = text.split(" ");
                var numbers = [];
                for(var i=0; i< text_split.length; i++)
                { 
                    var n = nlp(text_split[i]).match("#NumericValue").text();
                    if(n!="") numbers.push(n);
                }
                if(!numbers.length)
                    return false;
                text = numbers.join("");
                if(entity == "#PhoneNumber")
                    return this.checkPhoneFormatValidity(text)
            }
            if(entity == "#Date")
            {
                text = nlp(text).dates().format("{month-number} {date}").text()
                if(text=="") return false;
                else return text;
                /*
                var date = text.split(" ");
                date[0] = (parseInt(date[0])+1).toString()
                text = date.joint("-");*/
            }
            var doc = nlp(text)
            var text = doc.match(entity).text();
            
            if(entity == "#TextValue" || entity == "#Value"){
                text = text2num(text.toLowerCase()).toString()
                text = text.toUpperCase()
            }
            if(text!="")
                return text;
            return false;

        }

        getEntityInfo(entity)
        {
            return nlp.world.tags[entity];
        }

        getEntities()
        {
            if(this.entities.length == 0)
                this.initData()
            return this.entities;
        }

        getAllEntitiesInfo()
        {
            return nlp.world.tags;
        }

        checkPhoneFormatValidity(text)
        {
            text = text.replaceAll(" ", "");
            if(text.length >= 8 && text.length <= 15 ) //9 + 2 numbers for extension   
            {
                if(text[0] != '+')
                    text = '+'+text;
                return text
            }
            return false
        }

        addWordsToWorld(tag, words){
            if(this.entities.length == 0)
                this.initData()
            this.customEntities[tag] = words;
            words = words.replace(", ",",").split(",");
            var map = {};
            for(var i=0; i<words.length; i++)
            {
                map[words[i]] = tag;
            }
            if(this.entities.indexOf("#"+tag)<0)
                this.entities.push("#"+tag)
        
            nlp.extend((Doc, world) =>{
                // add new words to the lexicon
                world.addWords(map)
            })

        }
    }
    global.EntitiesManager = EntitiesManager;
    var Small = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9,
        'ten': 10,
        'eleven': 11,
        'twelve': 12,
        'thirteen': 13,
        'fourteen': 14,
        'fifteen': 15,
        'sixteen': 16,
        'seventeen': 17,
        'eighteen': 18,
        'nineteen': 19,
        'twenty': 20,
        'thirty': 30,
        'forty': 40,
        'fifty': 50,
        'sixty': 60,
        'seventy': 70,
        'eighty': 80,
        'ninety': 90
    };

    var Magnitude = {
        'thousand':     1000,
        'million':      1000000,
        'billion':      1000000000,
        'trillion':     1000000000000,
        'quadrillion':  1000000000000000,
        'quintillion':  1000000000000000000,
        'sextillion':   1000000000000000000000,
        'septillion':   1000000000000000000000000,
        'octillion':    1000000000000000000000000000,
        'nonillion':    1000000000000000000000000000000,
        'decillion':    1000000000000000000000000000000000,
    };

    var a, n, g;

    function text2num(s) {
        a = s.toString().split(/[\s-]+/);
        n = 0;
        g = 0;
        a.forEach(feach);
        return n + g;
    }

    function feach(w) {
        var x = Small[w];
        if (x != null) {
            g = g + x;
        }
        else if (w == "hundred") {
            g = g * 100;
        }
        else {
            x = Magnitude[w];
            if (x != null) {
                n = n + g * x
                g = 0;
            }
            else{
                n = w;
                g = "";
            }
        }
    }
})(this);

/**
 * Dependencies:
 *  HBTree
 */
(function _behaviourPlanner(global)
{
   /* var HBTree = global.HBTree;
    var HBTGraph = HBTree.HBTGraph;
    var HBTContext = HBTree.HBTContext;*/
    EntitiesManager = global.EntitiesManager;
    class Agent{
        constructor(o ,pos){
            this.uid =  "Agent-" + Date.now();
    
            this.initProperties();
            if(o){
                this.configure(o);
            }
    
            //Legacy in constructor pos
            this.position = pos;
    
            this.onUpdate = null;
    
            //this.hbtgraph is not used in HBTree
        }
    
        initProperties(){
            this.properties = {
                name: this.uid,
                valence:0,
                arousal:0,
                age: 35,
    
                target: null,
                look_at_pos: [0,0,10000],
                position: [0,0,0],
                orientation: [0,0,0,1],
                state: "waiting",
    
                //Internal for hbt
                bt_info: {running_data: {}},
            };
        }
    
        configure(o){
            if(o.uid){
                this.uid = o.uid;
                this.properties.name = o.uid;
            }
    
            if(o.properties){
                for(let k in o.properties){
                    this.properties[k] = o.properties[k];
                }
            }
        }
    
        //For HBT where is expected to be outside properties
        get position(){return this.properties.position;}
        set position(p){this.properties.position = p;}
        get bt_info(){return this.properties.bt_info;}
    
        serialize(){
            var o = {};
            o.uid = this.uid;
            o.properties = this.properties;
    
            return o;
        }
    }
    global.Agent = Agent;

    class User{
        constructor(o, pos){
            this.uid =  "User-"+ Date.now();
            this.initProperties();
            if(o){
                this.configure(o);
            }
    
            //Legacy in constructor pos
            this.position = pos;
    
            this.onUpdate = null;
        }
    
        initProperties(){
            this.properties = {
                name: this.uid,
                is_in_front: false,
                  is_speaking: false,
                valence: 0,
                arousal: 0,
                look_at_pos: [0,0,0],
                position: [0,0,0],
                orientation: [0,0,0,1],
                text: ""
            }
        }
    
        configure(o){
            if(o.uid){
                this.uid = o.uid;
                this.properties.name = o.uid;
            }
    
            if(o.properties){
                for(let k in o.properties){
                    this.properties[k] = o.properties[k];
                }
            }
        }
    
        //For HBT where is expected to be outside properties:
        get position(){return this.properties.position;}
        set position(p){this.properties.position = p;}
    
        serialize(){
            var o = {};
            o.uid = this.uid;
            o.properties = this.properties;
            return o;
        }
        // Delete "#" properties to discard unnecessary data
        cleanUserProperties()
        {
            var clean_user = Object.assign({}, this);
            for(var i in clean_user.properties)
                if(i.includes("#"))
                    clean_user.properties[i] = "";
            // Shallow copy does not keep the methods, so I need to add it
            clean_user.serialize = this.serialize;
            return clean_user;
            
        }
    }
    global.User = User;

    var BP_STATE = {
        STOP: 0,
        PLAYING: 1,
    };
    

    var EVENTS = {
        textRecieved: 0,
        imageRecieved: 1,
        faceDetected: 2,
        codeRecieved: 3
    };

    var last = now = 0;
    var accumulate_time = 0;
    var execution_t = 1;
    var triggerEvent = false;
    var corpus;

    var tmp = {
      /*  vec: vec3.create(),
        axis: vec3.create(),
        axis2: vec3.create(),
        inv_mat: mat4.create(),*/
        agent_anim: null,
        behaviours: null
    };

    //var userText = false;
    //var currentContext = null;
    //var currentHBTGraph = null;

    class BehaviourPlanner{

        constructor(o, options){
            this._user = null;
            this._agent = null;
            this._corpus = null;
            this._entities = null;
    
            this._hbt_graph = null;
    
            this.state = BP_STATE.STOP;
            this.accumulate_time = 0;
            this.execution_t = 1;
    
    
            //Callbacks
            this.onStateChange = null; //Not used
            this.onBehaviours = null; //Raw behaviour objects
            this.onActions = null; //Action objects (protocol) from processing behaviours
    
            //Init and configure
            this.init();
            if(o) this.configure(o);
            if(options) this.options = options;
        }
    
        set user(o){
            if(o.constructor !== User){
                console.log("Error while assigning User");
                return;
            }
    
            this._user = o;
    
            if(this.hbt_graph){
                this.blackboard.user = o;
            }
        }
    
        get user(){return this._user;}
    
        set agent(o){
            if(o.constructor !== Agent){
                console.log("Error while assigning Agent");
                return;
            }
    
            this._agent = o;
    
            if(this.hbt_graph){
                this.context.agent_evaluated = o;
                this.blackboard.agent = o;
            }
        }
    
        get agent(){return this._agent;}
        set corpus(o){this._corpus = o;}
        get corpus(){return this._corpus || null;}
    
        set hbt_graph(o){
            if(o.constructor !== HBTGraph){
                console.log("Graph must be HBTGraph");
                return;
            }
    
            this._hbt_graph = o;
    
            //Be sure that graph has context (it should be already set)
            if(!this._hbt_graph.graph.context){
                this._hbt_graph.graph.context = new HBTContext();
            }
    
            this.context.agent_evaluated = this.agent;
        
            //LAST: Set attributes of graph blackboard
            this.blackboard.configure({
                user: this.user,
                agent: this.agent,
                corpus: this.corpus,
                entities: this.entities,
            });
        }
    
        get hbt_graph(){return this._hbt_graph;}
        get context(){return this._hbt_graph ? this._hbt_graph.graph.context : null;}
        get blackboard(){return this._hbt_graph ? this._hbt_graph.graph.context.blackboard : null;}
    
        init(){
            this.user = new User();
            this.agent = new Agent();
            this.entitiesManager = EntitiesManager;
            this.state = BP_STATE.STOP;
            this.accumulate_time = 0;
            this.execution_t = 1;
        }
    
        configure(o){
            if(o.user) this.user = o.user;
            if(o.agent) this.agent = o.agent;
    
            if(o.hbt_graph) this.hbt_graph = o.hbt_graph;
        }
    
        play(){
            this.state = BP_STATE.PLAYING;
        }
    
        stop(){
            this.state = BP_STATE.STOP;
            this.context.last_event_node = null;
            this.context.running_nodes = null
        }
    
        update(dt){
            if(this.state == BP_STATE.PLAYING){
                this.accumulate_time += dt;
                if(this.accumulate_time >= this.execution_t){
                    //Evaluate agent on the graph
                    if(this.agent && this.hbt_graph){
                        let context = this.context;
    
                        if(context.running_nodes && context.running_nodes.length){
                            var behaviours = this.hbt_graph.runBehaviour(this.agent, this.context, this.accumulate_time, context.running_nodes[0]);
                            this.accumulate_time = 0; //runBehaviour expects time between calls
                            if(this.onBehaviours) this.onBehaviours(behaviours);
                            this.processBehaviours(behaviours);
                            if(!context.running_nodes || !context.running_nodes[0])
                                this.hbt_graph.graph.evaluation_behaviours = []; //TODO are subgraphs evaluation_behaviours emptied?
                        }
                        else if(context.last_event_node == null || context.last_event_node == undefined){
                            var behaviours = this.hbt_graph.runBehaviour(this.agent, context, this.accumulate_time);
                            this.accumulate_time = 0; //runBehaviour expects time between calls
    
                            if(this.onBehaviours) this.onBehaviours(behaviours);
                            this.processBehaviours(behaviours);
                            this.hbt_graph.graph.evaluation_behaviours = []; //TODO are subgraphs evaluation_behaviours emptied?
                        }
                    }
                }
            }
        }
    
        onEvent(e){
            if(this.state == BP_STATE.PLAYING){
                var node = this.hbt_graph.processEvent(e);
                if(node){
                    var behaviours = this.hbt_graph.runBehaviour(this.agent, this.context, this.accumulate_time, node);
                    this.accumulate_time = 0; //runBehaviour expects time between calls
    
                    if(this.onBehaviours) this.onBehaviours(behaviours);
                    this.processBehaviours(behaviours);
                    this.hbt_graph.graph.evaluation_behaviours = []; //TODO are subgraphs evaluation_behaviours emptied?
                }
            }
        }
    
        processBehaviours(behaviours){
            if(!behaviours || behaviours.length == 0) return;
            if(!this.onActions) return; //If no callback for actions do nothing
    
            //Temp to manage action messages
            let behaviours_message = {type: "behaviours", data: []};
            let actions = [];
    
            //Process all behaviours from HBT graph
            for(var b in behaviours){
                var behaviour = behaviours[b];
    
                switch(behaviour.type){
                    case B_TYPE.setProperty:
                        var data = behaviour.data;
                        let o = {};
                        o[data.name] = data.value;
                        this.blackboard.applyOn(o, data.type || "agent"); //TODO callback to refresh interface like in Agent.applyBehaviour (agent.js)
                        break;
    
                    case B_TYPE.intent:
                        var obj = {};
                        //TODO properly process intents and timetables to generate behaviours in protocol format
                        var data = behaviour.data;
    
                        if(data.text){
                            data.type = "speech";
                            var obj = { "speech": { text: data.text } }; //speaking
                        }else{
                            data.type = "anAnimation";
                            var obj = { type: data };
                        }
                        behaviours_message.data.push(data);
                        break;
    
                  case B_TYPE.timeline_intent:
                        var obj = {};
                        //TODO properly process intents and timetables to generate behaviours in protocol format
                        var bh = behaviour.data;
                        if(bh.data){
                            for(var i in bh.data){
                                var data = bh.data[i];
    
                                var obj = { type: data };
    
                                behaviours_message.data.push(data);
                            }
                        }else{
                            for(var i in bh){
                                var data = bh[i];
                                if(data.type == "speech"){
                                    var obj = { "speech": { text: data.text } }; //speaking
                                }else{
                                    var obj = { type: data };
                                }
                                behaviours_message.data.push(data);
                            }
                        }
                        break;
    
                    case B_TYPE.action:
                        //HARCODED
                        var expressions = {
                            angry:[-0.76,-0.64],
                            happy:[0.95,-0.25],
                            sad:[-0.81,0.57],
                            surprised:[0.22,-0.98],
                            sacred:[-0.23,-0.97],
                            disgusted:[-0.97,-0.23],
                            contempt:[-0.98,0.21],
                            neutral:[0,0]
                        };
                        var va = [0,0];
                        if(behaviour.data.animation_to_merge){
                            var g = behaviour.data.animation_to_merge.toLowerCase();
                            va = expressions[g];
                        }
                        var obj = {facialExpression: {va: va}}
                        if(behaviour.data.speed){
                            obj.facialExpression.duration = behaviour.data.speed;
                        }
    
                        //TODO properly process intents and timetables to generate behaviours in protocol format
                        var data = behaviour.data;
                        data.type = "facialLexeme";
                        data.lexeme = data.animation_to_merge; //Wrong, just a placeholder
                        behaviours_message.data.push(data);
                        break;
    
                    case B_TYPE.request:
                        if(behaviour.data.type.length != 0){
                            actions.push({type: "custom_action", data: behaviour.data});
                        }
                        break;
                }
            }
    
            if(behaviours_message.data.length) actions.push(behaviours_message);
    
            if(actions.length) this.onActions(actions);
        }
        
        //Process data message following protocol
        onData(msg){
            if(typeof(msg)=="string")
                msg = JSON.parse(msg);
                
            var type = msg.type;
            var data = msg.data;
    
            if(type != "data") return null;
    
            //Always updates data inside blackboard
            this.blackboard.apply(data); //Defined in behaviourGraph.js
    
            //Create event and process it in Graph
            this.onEvent(data);
        }
    
        //o must be graph data (data.behaviour)
        loadGraph(o){
            let graph = new HBTGraph();
            let context = new HBTContext();
            graph.graph.context = context;
            graph.graph.configure(o);

            this.hbt_graph = graph;

            return graph;
        }

        loadCorpus(o){
            o.array = [];
            for(var i in o.data){
                o.array.push(i);
            }
            this.corpus = o;

            return o;
        }
        loadPlanner(url, on_complete){
            var that = this;
            this.load( url, loadEnvironment.bind(this), null, null, null );
            
        }
        loadEnvironment(data)
        {
            var env = data.env;
            
            //Graphs
            for(var i in env.graphs){
                var graph = env.graphs[i];
                if(graph.behaviour){
                    if(graph.behaviour){
                        let hbt_graph = this.loadGraph(graph.behaviour);
                    }
                }
            }

            //Agent
            let agent = null;
            for(var i in env.agents){
                var data = env.agents[i];
                agent = new Agent(data);
            }

            if(agent){
                agent.is_selected = true;
                this.agent = agent;

        
            }

            //User
            if(env.user){
                let user = new User(env.user);
                this.user = user;
            }

            //Entities
            if(env.entities){
                for(var tag in env.entities){
                    this.entitiesManager.addWordsToWorld(tag,env.entities[tag]);
                }
            }
        }
        load( url, on_complete, on_error, on_progress, on_resources_loaded, on_loaded )
        {
            if(!url)
                return;
    
            var that = this;
    
            var extension = ONE.ResourcesManager.getExtension( url );
            var format_info = ONE.Formats.getFileFormatInfo( extension );
            if(!format_info) //hack, to avoid errors
                format_info = { dataType: "json" };
            
            
            //request scene file using our own library
            ONE.Network.request({
                url: url,
                nocache: true,
                dataType: extension == "json" ? "json" : (format_info.dataType || "text"), //datatype of json is text...
                success: extension == "json" ? inner_json_loaded : inner_data_loaded,
                progress: on_progress,
                error: inner_error
            });
    
            this._state = ONE.LOADING;
    
            /**
             * Fired before loading scene
             * @event beforeLoad
             */
           // LEvent.trigger(this,EVENT.BEFORE_LOAD);
    
            function inner_data_loaded( response )
            {
                if(on_complete)
                    on_complete(response)
            }
    
    
            function inner_json_loaded( response )
            {
                if(on_complete)
                {
                    var url = decodeURIComponent(response.env.iframe);
                    url = url.replace("https://webglstudio.org/latest/player.html?url=", "https://webglstudio.org/")
                    if(url.indexOf("https")==-1)
                        url = "https://webglstudio.org/"+ url;
                        on_complete(url,response.env.token)
                }   
    
                if( response.constructor !== Object )
                    throw("response must be object");
    
                var scripts = ONE.Scene.getScriptsList( response, true );
    
                //check JSON for special scripts
                if ( scripts.length )
                    that.loadScripts( scripts, function(){ inner_success(response); }, on_error );
                else
                    inner_success( response );
            }
    
            function inner_success( response )
            {
                if(on_loaded)
                    on_loaded(that, url);
    
                that.init();
                //Configure Behaviour Planner
                if(response.env.user)
                    that.user.configure(response.env.user);
                if(response.env.agents[0])
                 that.agent.configure(response.env.agents[0])
                that.loadGraph(response.env.graphs[0].behaviour)
    
                if(LS)
                    LS.Globals.sendMsg = that.onData.bind(that)
            }
    
    
            function inner_error(e)
            {
                var err_code = (e && e.target) ? e.target.status : 0;
                console.warn("Error loading scene: " + url + " -> " + err_code);
                if(on_error)
                    on_error(url, err_code, e);
            }
        }
    }
    global.BehaviourPlanner = BehaviourPlanner;

    function Loader(options)
    {
        options = options || {};
        this.options = options;
        this.bp = new BehaviourPlanner() ;
        this.bp.onActions = this.onActions;
        this.debug = false;
        this.autoplay = false;
        this.skip_play_button = false;

        this.last = this.now = performance.now();
        //this will repaint every frame and send events when the mouse clicks objects
        this.state = BehaviourPlanner.Loader.STOPPED;

        //set options
        this.configure( options );
        
    }

    /**
    * Loads a config file for the player, it could also load an scene if the config specifies one
    * @method loadConfig
    * @param {String} url url to the JSON file containing the config
    * @param {Function} on_complete callback trigged when the config is loaded
    * @param {Function} on_scene_loaded callback trigged when the scene and the resources are loaded (in case the config contains a scene to load)
    */
    Loader.prototype.loadConfig = function( url, on_complete, on_scene_loaded )
    {
        var that = this;
        ONE.Network.requestJSON( url, inner );
        function inner( data )
        {
            that.configure( data, on_scene_loaded );
            if(on_complete)
                on_complete(data);
        }
    }

    Loader.prototype.configure = function( options, on_scene_loaded )
    {
        var that = this;

        if(options.resources !== undefined)
            ONE.ResourcesManager.setPath( options.resources );

        if(options.proxy)
            ONE.ResourcesManager.setProxy( options.proxy );
        if(options.filesystems)
        {
            for(var i in options.filesystems)
                ONE.ResourcesManager.registerFileSystem( i, options.filesystems[i] );
        }

        if(options.allow_base_files)
            ONE.ResourcesManager.allow_base_files = options.allow_base_files;

        /*if(options.scene_url)
            this.loadScene( options.scene_url, on_scene_loaded );*/
    }
    Loader.STOPPED = 0;
    Loader.PLAYING = 1;
    Loader.PAUSED = 2;

    /**
    * Loads an scene and triggers start
    * @method loadPlanner
    * @param {String} url url to the JSON file containing all the behaviour planner info
    * @param {Function} on_complete callback trigged when the behaviour planner and the resources are loaded
    */
    Loader.prototype.loadPlanner = function(url, on_complete, on_progress)
    {
        var that = this;
        var bp = this.bp;
        if(this.options.proxy)
            url = ONE.ResourcesManager.proxy + url;
        bp.load( url, on_complete, null, inner_progress, inner_start );

        function inner_start()
        {
        }
        function inner_progress(){

        }
    }
    Loader.prototype.loadScene = function(url, room)
    {
        //LiteSCENE CODE *************************
        var settings = {
            alpha: false, //enables to have alpha in the canvas to blend with background
            stencil: true,
            redraw: true, //force to redraw
            autoplay: true,
            resources: "https://webglstudio.org/fileserver/files",
            autoresize: true, //resize the 3D window if the browser window is resized
            loadingbar: true, //shows loading bar progress
            proxy: "https://webglstudio.org/fileserver/files" //allows to proxy request to avoid cross domain problems, in this case the @ means same domain, so it will be http://hostname/proxy
        };
        /*SETTINGS_SETUP*/

        var player = new LS.Player(settings);

        var allow_remote_scenes = false; //allow scenes with full urls? this could be not safe...

        //support for external server
        var data = localStorage.getItem("wgl_user_preferences" );
        if(data)
        {
            var config = JSON.parse(data);
            if(config.modules.Drive && config.modules.Drive.fileserver_files_url)
            {
                allow_remote_scenes = true;
                LS.ResourcesManager.setPath( config.modules.Drive.fileserver_files_url );
            }
        }

        //allow to use Canvas2D call in the WebGLCanvas (this is not mandatory, just useful)
        if( window.enableWebGLCanvas )
            enableWebGLCanvas( gl.canvas );
        
        //this code defines which scene to load, in case you are loading an specific scene replce it by player.loadScene( scene_url )
        player.loadScene( url, inner_scene_loaded.bind(room, this) );
        function inner_scene_loaded(bpLoader, a){
            that.room = this.toString();
            if(LS)
                    LS.Globals.sendMsg = bpLoader.bp.onData.bind(bpLoader.bp)
            bpLoader.animate(that);
        }
    
        /*else if( allow_remote_scenes || url && url.indexOf("://") == -1) //for safety measures
            player.loadScene( url ); //the url must be something like: fileserver/files/guest/projects/Lee_FX.json
        else 
            player.loadConfig("config_BPplayer.json",player.loadScene);*/
    }
    Loader.prototype.animate = function(player){
        var that = this;
        player.ws = LS.Globals.ws = null;
    // if(player.ws.readyState == player.ws.OPEN && that.bp.state == BP_STATE.STOP)
        that.bp.play();

        that.last = that.now;
        that.now = performance.now();
        dt = (that.now - that.last) * 0.001;
        that.bp.update(dt);
        requestAnimationFrame(that.animate.bind(that, player));
    }
    Loader.prototype.update = function(dt)
    {
        //BP  
        this.bp.update(dt);
    }
    global.Loader = Loader;
})(this);


/* BEHAVIOUR NODES */


/**
 * This library expands HBTree with new nodes
 * 
 * Dependences:
 * 
 * LiteGraph
 * HBTree
 * xmlhttprequest
 * timelineContent
 */


 //const ANIM = require("./timelineContent").ANIM;
//ANIMATE by Javi Agenjo (@tamat) 2018 and modifyed by Eva Valls (2021) to define Agent Behaviors through the time
//ANIMATE by Javi Agenjo (@tamat) 2018 and modifyed by Eva Valls (2021) to define Agent Behaviors through the time
//************************************
//This file contains the code necessary to define BEHAVIOURS (verbal and non-verbal) based on BML standard (Project, Tracks and Clips definitions)
//All the editor features are in timelineEditor.js (TIMELINE_EDITOR)
/*
*
*/
(function _anim(global){
    ANIM = global.ANIM = {};
    
    var DEG2RAD = 0.0174532925;
    var RAD2DEG = 57.295779578552306;
    
    ANIM.REF_CLIP = 100;
    
    ANIM.LEFT = 1;
    ANIM.CENTER = 2;
    ANIM.RIGHT = 3;
    
    //inputs
    ANIM.LEFT_BUTTON = 1;
    ANIM.RIGHT_BUTTON = 2;
    ANIM.MIDDLE_BUTTON = 4;
    
    ANIM.clip_types = [];
    
    //player modes
    ANIM.PLAYING = 1;
    ANIM.PAUSED = 2;
    
    //blend modes
    ANIM.NORMAL = 0;
    ANIM.SCREEN = 1;
    ANIM.OVERLAY = 2;
    ANIM.MULTIPLY = 3;
    ANIM.DARKEN = 4;
    ANIM.HARD_LIGHT = 5;
    ANIM.SOFT_LIGHT = 6;
    ANIM.BLEND_MODES = ["Normal","Screen","Overlay","Multiply","Darken","Hard Light","Soft Light"];
    ANIM.blend_to_operation = {
        0: "source-over",
        1: "screen",
        2: "overlay",
        3: "multiply",
        4: "darken",
        5: "hard-light",
        6: "soft-light"
    };
    
    //clip types
    ANIM.MISSING_CLIP = -1; //used when after loading a clip the type is not found in the system
    ANIM.SPEECH = 0;
    ANIM.AUDIO = 1;
    ANIM.FACELEXEME = 2;
    ANIM.FACEFACS = 3;
    ANIM.FACEEMOTION = 4;
    ANIM.GAZE = 5;
    ANIM.GESTURE = 6;
    ANIM.HEAD = 7;
    ANIM.HEADDIRECTION = 8;
    ANIM.POSTURE = 9;
    ANIM.LOCOMOTION = 10;
    
    ANIM.CUSTOM = 11;
    
    ANIM.clip_types = [ SpeechClip, AudioClip, FaceLexemeClip, FaceFACSClip, FaceEmotionClip, GazeClip, GestureClip, HeadClip, HeadDirectionShiftClip, PostureClip] ;
    ANIM.track_types = {"Speech": [ SpeechClip, AudioClip], "FaceShift": [FaceLexemeClip/*, FaceFACSClip*/], "Face": [FaceLexemeClip, FaceFACSClip, FaceEmotionClip], "Gaze": [GazeClip],"GazeShift": [GazeClip], "Gesture":[GestureClip], "Head": [HeadClip],"HeadDirectionShift": [HeadDirectionShiftClip], "Posture": [PostureClip], "PostureShift": [PostureClip] };
    ANIM.registerClipType = function(ctor)
    {
        var name = ctor.name;
        ANIM.clip_types[ ctor.id ] = ctor;
        for(var i in BaseClip.prototype)
            ctor.prototype[i] = BaseClip.prototype[i];
        ANIM[ name ] = ctor;
    }
    
    // PROJECT ****************************************************
    //a project contains tracks, a track contains clips, and a clip could contain frames
    function Project()
    {
        this.name = "unnamed";
    
        //timing
        this.mode = ANIM.PAUSED;
        this.current_time = 0;
        this.duration = 60;
        this.framerate = 30;
        this.volume = 1;
        this.type = ANIM.CANVAS2D;
        this.allow_seeking = true;
    
        //canvas
        this.size = [1280,720]; //project res
    
        //tracks: similar to layers
        this.tracks = []; //all tracks
        this.markers = []; //time markers
    
        //scripts
        this.includes = []; //urls to js files that must be imported
        this.scripts = {}; //scripts that could be used in this project
        this.globals = {}; //container to store global vars between clips
        this.texts = {}; //generic container for text data
    
        //external
        this.fonts = []; //fonts that must be loaded from Google Fonts
    
        this.clip_types = []; //list of all available clip types
    
        this.clear();
    
        Project.instance = this;
    }
    
    ANIM.Project = Project;
    
    Project.prototype.add = function(track)
    {
        if(track.constructor !== ANIM.Track)
            throw("only tracks allowed to be added to project");
        this.tracks.push( track );
        track._project = this;
        return track;
    }
    
    Project.prototype.getTrack = function( id )
    {
        if(id.constructor === String)
        {
            for(var i = 0; i < this.tracks.length; ++i )
                if( this.tracks[i].name == id )
                    return this.tracks[i];
            return null;
        }
        return this.tracks[ Number(id) ];
    }
    
    
    Project.prototype.clear = function( skip_default_tracks )
    {
        this.current_time = 0;
    
        this.globals = {};
        this.tracks.length = 0;
        this.markers.length = 0;
    
        this.includes = [];
        this.scripts = {};
        this.fonts = [];
    }
    
    
    Project.prototype.load = function( url, on_complete )
    {
        var that = this;
        fetch(url)
        .then(function(response) {
            if(response.status == 404)
            {
                if(on_complete)
                    on_complete(null);
            }
            else
              return response.json();
        }).then( function(data){
            if(data)
                that.fromJSON(data, on_complete);
        });/*.catch(function(err){
            console.error( "error loading project: " + err );
        });
        */
    }
    
    Project.prototype.toJSON = function()
    {
        var json = {};
    
        json.name = this.name;
    
        json.current_time = this.current_time;
        json.duration = this.duration;
        json.framerate = this.framerate;
        json.size = this.size;
        json.markers = this.markers;
        json.texts = this.texts;
    
        json.includes = this.includes;
        json.scripts = [];
        for(var i in this.scripts)
        {
            var script = this.scripts[i];
            json.scripts.push({ name: script.name, code: script.code });
        }
    
    
    
        json.tracks = [];
        for(var i = 0; i < this.tracks.length; ++i)
            json.tracks.push( this.tracks[i].toJSON() );
    
        json.fonts = this.fonts;
    
        return json;
    }
    
    Project.prototype.fromJSON = function(json, callback)
    {
    
        this.current_time = json.current_time || 0;
        this.duration = json.duration;
        this.framerate = json.framerate;
        this.size = json.size;
    
        this.tracks.length = 0;
        this.markers = json.markers || [];
            if(callback)
                callback();
        }
    
    //when coding clips from external scripts, you need a way to ensure clip classes hasnt been modifyed
    Project.prototype.checkClips = function()
    {
        for(var j = 0; j < this.tracks.length; ++j)
        {
            var track = this.tracks[j];
            for(var i = 0; i < this.clips.length; ++i)
            {
                var clip = this.clips;
                var ctor_class = ANIM.clip_types[ clip.constructor.id ];
                if(clip.constructor === ctor_class)
                    continue;
                var new_clip = new ctor_class();
                new_clip.fromJSON( clip.toJSON() );
                new_clip.start = clip.start;
                new_clip.duration = clip.duration;
                this.clips[i] = new_clip;
            }
        }
    }
    
    function Track( name )
    {
        this.name = name || "noname";
        this.clips = [];
        this.hidden = false;
        this.editable = true;
        this._project = null;
        this.current_clip = null;
    }
    
    Track.prototype.getIndex = function()
    {
        return this._project.tracks.indexOf(this);
    }
    
    Track.prototype.toJSON = function()
    {
        var json = {
            name: this.name,
            clips: [],
            editable: this.editable,
            hidden: this.hidden
        };
        for(var i = 0; i < this.clips.length; ++i)
        {
            var shift = false;
            
            if(this.name.includes("Shift"))
                shift = true;
            var clip = this.clips[i];
            var data = ANIM.clipToJSON( clip );
            if(data)
            {
                data.shift = shift;
                json.clips.push( data );
            }
                
        }
    
        return json;
    }
    
    ANIM.clipToJSON = function( clip )
    {
        var id;
        var data;
        if( clip.constructor === ANIM.MissingClip )
        {
            id = clip.missing_type;
            data = clip.json;
        }
        else if(clip.toJSON)
        {
            id = clip.constructor.id;
            data = clip.toJSON();
        }
        else
        {
            console.warn("Clip without toJSON, data not serialized");
            return null;
        }
        if( clip.fadein )
            data.fadein = clip.fadein;
        if( clip.fadeout )
            data.fadeout = clip.fadeout;
        if( clip.control_channels )
        {
            data.ccs = [];
            for(var i = 0; i < clip.control_channels.length; ++i)
                data.ccs.push( clip.control_channels[i].toJSON() );
        }
    
        return [ id, clip.start, clip.duration, data ];
    }
    
    Track.prototype.fromJSON = function(json)
    {
        this.name = json.name;
        this.editable = json.editable;
        this.hidden = json.hidden;
    
        if(!json.clips)
        {
            console.warn("track without clips");
            return;
        }
    
        for(var i = 0; i < json.clips.length; ++i)
        {
            var clip_data = json.clips[i];
            var clip = ANIM.clipFromJSON( clip_data );
            this.add( clip );
        }
    }
    
    ANIM.clipFromJSON = function( clip_data, clip )
    {
        var type = ANIM.clip_types[ clip_data[0] ];
        clip = clip || null;
        if(!clip)
        {
            if(type)
                clip = new type();
            else
            {
                console.error("Clip type id unknown:", clip_data[0] );
                clip = new ANIM.MissingClip();
                clip.missing_type = clip_data[0];
                clip.json = clip_data[3];
            }
        }
        clip.start = clip_data[1];
        clip.duration = clip_data[2];
        if(clip.fromJSON)
            clip.fromJSON( clip_data[3] );
        else if( clip.constructor !== ANIM.MissingClip )
            console.warn("Clip without fromJSON: ", clip_data[0] );
        var data = clip_data[3];
    
            clip.fadeout = data.fadeout;
        if( data.ccs )
        {
            clip.control_channels = [];
            for(var i = 0; i < data.ccs.length; ++i)
                clip.control_channels.push( new ANIM.ControlChannel( data.ccs[i] ) );
        }
    
        return clip;
    }
    
    //used to render the content of this track so it doesnt have to be rendered constantly
    Track.prototype.getTempCanvas = function()
    {
        if(!this._temp_canvas)
            this._temp_canvas = document.createElement("canvas");
        return this._temp_canvas;
    }
    
    
    Track.prototype.add = function( clip, time, duration )
    {
        if(time !== undefined)
        {
            if(isNaN(time))
            {
                console.error("NaN in time");
                return;
            }
            clip.start = time;
        }
        if(duration !== undefined)
            clip.duration = duration;
        clip._track = this;
        this.clips.push( clip );
        this.sortClips();
    }
    
    Track.prototype.remove = function(clip)
    {
        var index = this.clips.indexOf(clip);
        if(index != -1)
            this.clips.splice(index,1);
        this.sortClips();
    }
    
    Track.prototype.sortClips = function()
    {
        this.clips.sort( function(a,b) {return a.start - b.start; });
    }
    
    Track.prototype.getClipAtTime = function(time)
    {
        for(var i = 0, l = this.clips.length; i < l; ++i)
        {
            var clip = this.clips[i];
            if(clip.start > time || (clip.start + clip.duration) < time )
                continue;
            return clip;
        }
        return null;
    }
    
    Track.prototype.getClipsInRange = function(start,end)
    {
        var res = [];
        for(var i = 0, l = this.clips.length; i < l; ++i)
        {
            var clip = this.clips[i];
            if(clip.start > end || (clip.start + clip.duration) < start )
                continue;
            res.push(clip);
        }
        return res;
    }
    
    ANIM.Track = Track;
    
    // CONTROL CHANNEL : used to store keyframes
    
    function ControlChannel(o)
    {
        this.name = "param";
        this.type = ANIM.NUMBER;
        this.values = [];
        this.interpolation_type = ANIM.LINEAR;
        if(o)
            this.fromJSON(o);
    }
    
    ANIM.ControlChannel = ControlChannel;
    
    ControlChannel.prototype.fromJSON = function(o)
    {
        this.type = o.type;
        this.name = o.name;
        this.values = o.values;
    }
    
    ControlChannel.prototype.toJSON = function()
    {
        return {
            type: this.type,
            name: this.name,
            values: this.values.concat()
        };
    }
    
    ControlChannel.prototype.addKeyframe = function( time, value )
    {
        var k = [time,value];
        for(var i = 0; i < this.values.length; ++i)
        {
            if( this.values[i][0] > time )
            {
                this.values.splice(i,0,k);
                return k;
            }
        }
        this.values.push(k);
        return k;
    }
    
    ControlChannel.prototype.removeKeyframe = function( keyframe )
    {
        for(var i = 0; i < this.values.length; ++i)
        {
            if( this.values[i] == keyframe )
            {
                this.values.splice(i,1);
                return;
            }
        }
    }
    
    ControlChannel.prototype.removeKeyframeByTime = function( time )
    {
        for(var i = 0; i < this.values.length; ++i)
        {
            if( Math.abs( this.values[i][0] - time ) < 0.001 )
            {
                this.values.splice(i,1);
                return;
            }
        }
    }
    
    ControlChannel.prototype.removeKeyframeByIndex = function( index )
    {
        this.values.splice(index,1);
    }
    
    ControlChannel.prototype.sort = function()
    {
        this.values.sort( function(a,b) { return a[0] - b[0]; } );
    }
    
    ControlChannel.prototype.getSample = function( time )
    {
        if(!this.values.length)
            return null;
    
        //sample value
        var prev;
        var next;
        for(var j = 0; j < this.values.length; ++j)
        {
            var v = this.values[j];
            if(v[0] < time)
            {
                prev = v;
                continue;
            }
            next = v;
            break;
        }
    
        if(!prev && !next)
            return 0; //no data
    
        if(!prev && next)
            return next[1];
    
        if(prev && !next)
            return prev[1];
    
        var f = (time - prev[0]) / (next[0] - prev[0]);
        if(this.type == ANIM.NUMBER)
            return prev[1] * (1-f) + next[1] * (f);
    
        return null;
    }
    
    
    // CLIPS *******************************************************
    //-----------------------------Face Behaviour-----------------------------//
    //FaceLexemeClip to show captions
    FaceLexemeClip.lexemes = ["LIP_CORNER_DEPRESSOR", "LIP_CORNER_DEPRESSOR_LEFT","LIP_CORNER_DEPRESSOR_RIGHT",	"LIP_CORNER_PULLER","LIP_CORNER_PULLER_LEFT","LIP_CORNER_PULLER_RIGHT", "MOUTH_OPEN","LOWER_LIP_DEPRESSOR",
        "CHIN_RAISER","LIP_PUCKERER","TONGUE_SHOW","LIP_STRECHER","LIP_FUNNELER","LIP_TIGHTENER","LIP_PRESSOR","BROW_LOWERER","BROW_LOWERER_LEFT","LOWER_RIGHT_BROW",	"INNER_BROW_RAISER","OUTER_BROW_RAISER",	"RAISE_LEFT_BROW","RAISE_RIGHT_BROW",	"UPPER_LID_RAISER",	"LID_TIGHTENER",
        "EYES_CLOSED","BLINK","WINK","NOSE_WRINKLER","UPPER_LIP_RAISER","DIMPLER","JAW_DROP","MOUTH_STRETCH"];
    
    
    function FaceLexemeClip()
    {
        this.id= "faceLexeme-"+Math.ceil(getTime());;
    
        this.start = 0
        this.duration = 1;
    
        this._width = 0;
    
        this.properties = {
            amount : 0.5,
            attackPeak : 0.25,
            relax : 0.75,
            lexeme : FaceLexemeClip.lexemes[0]
            /*permanent : false,*/
        }
    
        this.color = "black";
        this.font = "40px Arial";
    
      this.clip_color = "#94e9d9";
      //this.icon_id = 37;
    }
    FaceLexemeClip.type = "faceLexeme";
    FaceLexemeClip.id = ANIM.FACELEXEME? ANIM.FACELEXEME:2;
    FaceLexemeClip.clip_color = "cyan";
    ANIM.registerClipType( FaceLexemeClip );
    
    FaceLexemeClip.prototype.toJSON = function()
    {
        var json = {
            id: this.id,
            start: this.start,
            duration: this.duration,
        }
        for(var i in this.properties)
        {
            json[i] = this.properties[i];
        }
        return json;
    }
    
    FaceLexemeClip.prototype.fromJSON = function( json )
    {
        this.id = json.id;
        this.properties.amount = json.amount;
        this.start = json.start;
        this.properties.attackPeak = json.attackPeak;
        this.properties.relax = json.relax;
        this.duration = json.duration;
        this.properties.lexeme = json.lexeme;
        /*this.properties.permanent = json.permanent;*/
    
    }
    
    FaceLexemeClip.prototype.drawTimeline = function( ctx, project, w,h, selected )
    {
        //ctx.globalCompositeOperation =  "source-over";
        var text_info = ctx.measureText( this.id );
        ctx.fillStyle = this.color;
        if( text_info.width < (w - 24) )
            ctx.fillText( this.id, 24,h * 0.7 );
    }
    FaceLexemeClip.prototype.showInfo = function(panel)
    {
        for(var i in this.properties)
        {
            var property = this.properties[i];
            if(i=="lexeme"){
                panel.addCombo(i, property,{values: FaceLexemeClip.lexemes, callback: function(i,v)
                {
                    this.properties[i] = v;
                }.bind(this, i)});
            }
            else
            {
                switch(property.constructor)
                {
    
                    case String:
                        panel.addString(i, property, {callback: function(i,v)
                        {
                            this.properties[i] = v;
                        }.bind(this, i)});
                        break;
                    case Number:
                        if(i=="amount")
                        {
                            panel.addNumber(i, property, {min:0, max:1,callback: function(i,v)
                            {
                                this.properties[i] = v;
                            }.bind(this,i)});
                        }
                        else{
                            panel.addNumber(i, property, {callback: function(i,v)
                            {
                                if(i == "start"){
                                    var dt = v - this.properties[i];
                                    this.properties.attackPeak += dt;
                                    this.properties.relax += dt;
                                }
                                this.properties[i] = v;
                            }.bind(this,i)});
                        }
                        break;
                    case Boolean:
                        panel.addCheckbox(i, property, {callback: function(i,v)
                        {
                            this.properties[i] = v;
                        }.bind(this,i)});
                            break;
                    case Array:
                        panel.addArray(i, property, {callback: function(i,v)
                        {
                            this.properties[i] = v;
                        }.bind(this,i)});
                            break;
                }
            }
        }
    }
    //FaceFACSClip
    FaceFACSClip.type = "faceFACS";
    FaceFACSClip.sides = ["LEFT", "RIGHT", "BOTH"];
    function FaceFACSClip()
    {
        this.id= "faceFACS-"+Math.ceil(getTime());;
        this.start = 0
        this.duration = 1;
        this._width = 0;
    
        this.properties = {
            amount : 0.5,
            attackPeak : 0.25,
            relax : 0.75,
            au : 0,
            side : "BOTH", //[LEFT, RIGHT, BOTH](optional)
            base : false
        }
        this.color = "black";
        this.font = "40px Arial";
    
    }
    
    FaceFACSClip.id = ANIM.FACEFACS? ANIM.FACEFACS:3;
    FaceFACSClip.clip_color = "#00BDFF";
    ANIM.registerClipType( FaceFACSClip );
    
    FaceFACSClip.prototype.toJSON = function()
    {
        var json = {
            id: this.id,
            start: this.start,
            duration: this.duration,
    
        }
        for(var i in this.properties)
        {
            if(i == "base")
            {
                if(this.properties[i])
                    json.type = "faceShift";
                continue;
            }
            json[i] = this.properties[i];
        }
        return json;
    }
    
    FaceFACSClip.prototype.fromJSON = function( json )
    {
        this.id = json.id;
        this.properties.amount = json.amount;
        this.start = json.start;
        this.properties.attackPeak = json.attackPeak;
        this.properties.relax = json.relax;
        this.duration = json.duration;
        this.properties.au = json.au;
        /*this.properties.permanent = json.permanent;*/
        this.properties.side = json.side;
    }
    
    FaceFACSClip.prototype.drawTimeline = function( ctx, project, w,h, selected )
    {
        ctx.globalCompositeOperation =  "source-over";
        var text_info = ctx.measureText( this.id );
        ctx.fillStyle = this.color;
        if( text_info.width < (w - 24) )
            ctx.fillText( this.id, 24,h * 0.7 );
    }
    FaceFACSClip.prototype.showInfo = function(panel)
    {
        for(var i in this.properties)
        {
            var property = this.properties[i];
            if(i=="side"){
                panel.addCombo(i, property,{values: FaceFACSClip.sides, callback: function(i,v)
                {
                    this.properties[i] = v;
                }.bind(this, i)});
            }
            else
            {
                switch(property.constructor)
                {
    
                    case String:
                        panel.addString(i, property, {callback: function(i,v)
                        {
                            this.properties[i] = v;
                        }.bind(this, i)});
                        break;
                    case Number:
                        if(i=="amount")
                        {
                            panel.addNumber(i, property, {min:0, max:1,callback: function(i,v)
                            {
                                this.properties[i] = v;
                            }.bind(this,i)});
                        }
                        else{
                            panel.addNumber(i, property, {callback: function(i,v)
                            {
                                if(i == "start"){
                                    var dt = v - this.properties[i];
                                    this.properties.attackPeak += dt;
                                    this.properties.relax += dt;
                                }
                                this.properties[i] = v;
                            }.bind(this,i)});
                        }
                    break;
                    case Boolean:
                        panel.addCheckbox(i, property, {callback: function(i,v)
                        {
                            this.properties[i] = v;
                        }.bind(this,i)});
                            break;
                    case Array:
                        panel.addArray(i, property, {callback: function(i,v)
                        {
                            this.properties[i] = v;
                        }.bind(this,i)});
                            break;
                }
            }
        }
    }
    //FaceEmotionClip
    FaceEmotionClip.type = "faceEmotion";
    FaceEmotionClip.emotions = ["HAPPINESS", "SADNESS", "SURPRISE", "FEAR","ANGER","DISGUST", "CONTEMPT"];
    function FaceEmotionClip()
    {
        this.id= "faceEmotion-"+Math.ceil(getTime());;
        this.start = 0
        this.duration = 1;
        this._width = 0;
    
        this.properties = {
            amount : 0.5,
            attackPeak : 0.25,
            relax : 0.75,
            emotion : "HAPPINESS", 
        }
        this.color = "black";
        this.font = "40px Arial";
    
    }
    
    FaceEmotionClip.id = ANIM.FACEEMOTION? ANIM.FACEEMOTION:4;
    FaceEmotionClip.clip_color = "#00BDFF";
    ANIM.registerClipType( FaceEmotionClip );
    
    FaceEmotionClip.prototype.toJSON = function()
    {
        var json = {
            id: this.id,
            start: this.start,
            duration: this.duration,
    
        }
        for(var i in this.properties)
        {
            
            json[i] = this.properties[i];
        }
        return json;
    }
    
    FaceEmotionClip.prototype.fromJSON = function( json )
    {
        this.id = json.id;
        this.properties.amount = json.amount;
        this.start = json.start;
        this.properties.attackPeak = json.attackPeak;
        this.properties.relax = json.relax;
        this.duration = json.duration;
        this.properties.emotion = json.emotion;
        /*this.properties.permanent = json.permanent;*/
    
    }
    
    FaceEmotionClip.prototype.drawTimeline = function( ctx, project, w,h, selected )
    {
        ctx.globalCompositeOperation =  "source-over";
        var text_info = ctx.measureText( this.id );
        ctx.fillStyle = this.color;
        if( text_info.width < (w - 24) )
            ctx.fillText( this.id, 24,h * 0.7 );
    }
    FaceEmotionClip.prototype.showInfo = function(panel)
    {
        for(var i in this.properties)
        {
            var property = this.properties[i];
            if(i=="emotion"){
                panel.addCombo(i, property,{values: FaceEmotionClip.emotions, callback: function(i,v)
                {
                    this.properties[i] = v;
                }.bind(this, i)});
            }
            else
            {
                switch(property.constructor)
                {
    
                    case String:
                        panel.addString(i, property, {callback: function(i,v)
                        {
                            this.properties[i] = v;
                        }.bind(this, i)});
                        break;
                    case Number:
                        if(i=="amount")
                        {
                            panel.addNumber(i, property, {min:0, max:1,callback: function(i,v)
                            {
                                this.properties[i] = v;
                            }.bind(this,i)});
                        }
                        else{
                            panel.addNumber(i, property, {callback: function(i,v)
                            {
                                if(i == "start"){
                                    var dt = v - this.properties[i];
                                    this.properties.attackPeak += dt;
                                    this.properties.relax += dt;
                                }
                                this.properties[i] = v;
                            }.bind(this,i)});
                        }
                    break;
                    case Boolean:
                        panel.addCheckbox(i, property, {callback: function(i,v)
                        {
                            this.properties[i] = v;
                        }.bind(this,i)});
                            break;
                    case Array:
                        panel.addArray(i, property, {callback: function(i,v)
                        {
                            this.properties[i] = v;
                        }.bind(this,i)});
                            break;
                }
            }
        }
    }
    /*----------------------------------Gaze Behaviour-----------------------------------*/
    //GazeClip
    GazeClip.type = "gaze";
    GazeClip.influences = ["EYES", "HEAD", "SHOULDER", "WAIST", "WHOLE"];
    GazeClip.directions = ["","RIGHT", "LEFT", "UP", "DOWN", "UPRIGHT", "UPLEFT", "DOWNLEFT", "DOWNRIGHT"];
    function GazeClip()
    {
        this.id= "gaze-"+Math.ceil(getTime());
        this.start = 0
        this.duration = 1;
    
        this._width = 0;
    
        this.properties = {
            target : "",
            ready : 0.25, //if it's not permanent
            relax : 0.75, //if it's not permanent
            influence : "EYES", //[EYES, HEAD, SHOULDER, WAIST, WHOLE](optional)
            offsetAngle : 0.0, //(optional)
            offsetDirection : "RIGHT", //[RIGHT, LEFT, UP, DOWN, UPRIGHT, UPLEFT, DOWNLEFT, DOWNRIGHT](optional)
            base : false
        }
        this.color = "black";
        this.font = "40px Arial";
    
    }
    
    GazeClip.id = ANIM.GAZE? ANIM.GAZE:5;
    GazeClip.clip_color = "fuchsia";
    ANIM.registerClipType( GazeClip );
    
    GazeClip.prototype.toJSON = function()
    {
        var json = {
            id: this.id,
            start: this.start,
            duration: this.duration,
            type: "gaze"
        }
        for(var i in this.properties)
        {
            if(i == "base")
            {
                if(this.properties[i])
                    json.type = "gazeShift";
                continue;
            }
    
            json[i] = this.properties[i];
        }
        return json;
    }
    
    GazeClip.prototype.fromJSON = function( json )
    {
        this.id = json.id;
        this.properties.target = json.target;
        this.start = json.start;
        this.properties.ready = json.ready;
        this.properties.relax = json.relax;
        this.duration = json.duration;
        this.properties.influence = json.influence;
        this.properties.offsetAngle = json.offsetAngle;
        this.properties.offsetDirection = json.offsetDirection;
        /*this.properties.permanent = json.permanent;*/
    }
    
    GazeClip.prototype.drawTimeline = function( ctx, project, w,h, selected )
    {
        ctx.globalCompositeOperation =  "source-over";
        var text_info = ctx.measureText( this.id );
        ctx.fillStyle = this.color;
        if( text_info.width < (w - 24) )
            ctx.fillText( this.id, 24,h * 0.7 );
    }
    GazeClip.prototype.showInfo = function(panel)
    {
        for(var i in this.properties)
        {
            var property = this.properties[i];
            if(i=="influence"){
                panel.addCombo(i, property,{values: GazeClip.influences, callback: function(i,v)
                {
                    this.properties[i] = v;
                }.bind(this, i)});
            }
            else if(i=="offsetDirection"){
                panel.addCombo(i, property,{values: GazeClip.directions, callback: function(i,v)
                {
                    this.properties[i] = v;
                }.bind(this, i)});
            }
            else
            {
                switch(property.constructor)
                {
    
                    case String:
                        panel.addString(i, property, {callback: function(i,v)
                        {
                            this.properties[i] = v;
                        }.bind(this, i)});
                        break;
                    case Number:
                        if(i=="amount")
                        {
                            panel.addNumber(i, property, {min:0, max:1,callback: function(i,v)
                            {
                                this.properties[i] = v;
                            }.bind(this,i)});
                        }
                        else{
                            panel.addNumber(i, property, {callback: function(i,v)
                            {
                                if(i == "start"){
                                    var dt = v - this.properties[i];
                                    this.properties.ready += dt;
                                    this.properties.relax += dt;
                                }
                                this.properties[i] = v;
                            }.bind(this,i)});
                        }
                        break;
                    case Boolean:
                        panel.addCheckbox(i, property, {callback: function(i,v)
                        {
                            this.properties[i] = v;
                        }.bind(this,i)});
                            break;
                    case Array:
                        panel.addArray(i, property, {callback: function(i,v)
                        {
                            this.properties[i] = v;
                        }.bind(this,i)});
                            break;
                }
            }
        }
    }
    /*----------------------------------Gesture Behaviour-----------------------------------*/
    //GestureClip
    GestureClip.type = "gesture";
    GestureClip.modes = ["","LEFT_HAND", "RIGHT_HAND", "BOTH_HANDS"];
    function GestureClip()
    {
        this.id= "gesture-"+Math.ceil(getTime());;
        this.type = "gesture";
        this.start = 0
        this.duration = 1.75;
    
        this._width = 0;
    
        this.properties = {
            lexeme : "",
            mode : "",
            ready : 0.25,
            strokeStart : 0.75,
            stroke : 1,
            strokeEnd : 1.25,
            relax : 1.5,
            target : [0,0,0] //gesture is directed towards that target (optional) for pointing
        }
        this.color = "black";
        this.font = "40px Arial";
    
    }
    
    GestureClip.id = ANIM.GESTURE? ANIM.GESTURE:6;
    GestureClip.clip_color = "lime";
    ANIM.registerClipType( GestureClip );
    
    GestureClip.prototype.toJSON = function()
    {
        var json = {
            id: this.id,
            start: this.start,
            duration: this.duration
        }
        for(var i in this.properties)
        {
            json[i] = this.properties[i];
        }
    
        return json;
    }
    
    GestureClip.prototype.fromJSON = function( json )
    {
        this.id = json.id;
        this.properties.lexeme  = json.lexeme;
        this.start = json.start;
        this.properties.ready = json.ready;
        this.properties.strokeStart = json.strokeStart;
        this.properties.stroke = json.stroke;
        this.properties.strokeEnd = json.strokeEnd;
        this.properties.relax = json.relax;
        this.duration = json.duration;
        this.properties.target = json.target;
    
    }
    
    GestureClip.prototype.drawTimeline = function( ctx, project, w,h, selected )
    {
        //ctx.globalCompositeOperation =  "source-over";
        var text_info = ctx.measureText( this.id );
        ctx.fillStyle = this.color;
        if( text_info.width < (w - 24) )
            ctx.fillText( this.id, 24,h * 0.7 );
    }
    GestureClip.prototype.showInfo = function(panel)
    {
        for(var i in this.properties)
        {
            var property = this.properties[i];
            if(i=="mode"){
                panel.addCombo(i, property,{values: GestureClip.modes, callback: function(i,v)
                {
                    this.properties[i] = v;
                }.bind(this, i)});
            }
            else
            {
                switch(property.constructor)
                {
    
                    case String:
                        panel.addString(i, property, {callback: function(i,v)
                        {
                            this.properties[i] = v;
                        }.bind(this, i)});
                        break;
                    case Number:
                        if(i=="amount")
                        {
                            panel.addNumber(i, property, {min:0, max:1,callback: function(i,v)
                            {
                                this.properties[i] = v;
                            }.bind(this,i)});
                        }
                        else{
                            panel.addNumber(i, property, {callback: function(i,v)
                            {
                                if(i == "start"){
                                    var dt = v - this.properties[i];
                                    this.properties.ready += dt;
                                    this.properties.strokeStart += dt;
                                    this.properties.stroke += dt;
                                    this.properties.strokeEnd += dt;
                                    this.properties.relax += dt;
                                }
                                this.properties[i] = v;
                            }.bind(this,i)});
                        }
                        break;
                    case Boolean:
                        panel.addCheckbox(i, property, {callback: function(i,v)
                        {
                            this.properties[i] = v;
                        }.bind(this,i)});
                            break;
                    case Array:
                        panel.addArray(i, property, {callback: function(i,v)
                        {
                            this.properties[i] = v;
                        }.bind(this,i)});
                            break;
                }
            }
        }
    }
    /*----------------------------------Head Behaviour-----------------------------------*/
    //HeadClip
    HeadClip.type = "head";
    HeadClip.lexemes = ["NOD", "SHAKE", "TILD"];
    function HeadClip()
    {
        this.id= "head-"+Math.ceil(getTime());;
    
        this.start = 0;
        this.duration = 1.5;
    
        this._width = 0;
    
        this.properties = {
            lexeme : HeadClip.lexemes[0], //[NOD,SHAKE, TILD...]
            repetition : 1, //[1,*] (optional)
            amount : 1, //[0,1]
            ready : 0.15,
            strokeStart : 0.5,
            stroke : 0.75,
            strokeEnd : 1,
            relax : 1.15
        }
    
        this.color = "black";
        this.font = "40px Arial";
    
    }
    
    HeadClip.id = ANIM.HEAD? ANIM.HEAD:7;
    HeadClip.clip_color = "yellow";
    ANIM.registerClipType( HeadClip );
    
    HeadClip.prototype.toJSON = function()
    {
        var json = {
            id: this.id,
            start: this.start,
            duration: this.duration,
        }
        for(var i in this.properties)
        {
            json[i] = this.properties[i];
        }
        return json;
    }
    
    HeadClip.prototype.fromJSON = function( json )
    {
        this.id = json.id;
        this.properties.lexeme = json.lexeme;
        this.properties.repetition = json.repetition;
        this.properties.amount = json.amount;
        this.start = json.start;
        this.properties.ready = json.ready;
        this.properties.strokeStart = json.strokeStart;
        this.properties.stroke = json.stroke;
        this.properties.strokeEnd = json.strokeEnd;
        this.properties.relax = json.relax;
        this.duration = json.duration;
    }
    
    HeadClip.prototype.drawTimeline = function( ctx, project, w,h, selected )
    {
        //ctx.globalCompositeOperation =  "source-over";
        var text_info = ctx.measureText( this.id );
        ctx.fillStyle = this.color;
        if( text_info.width < (w - 24) )
            ctx.fillText( this.id, 24,h * 0.7 );
    }
    HeadClip.prototype.showInfo = function(panel)
    {
        for(var i in this.properties)
        {
            var property = this.properties[i];
            if(i=="lexeme"){
                panel.addCombo(i, property,{values: HeadClip.lexemes, callback: function(i,v)
                {
                    this.properties[i] = v;
                }.bind(this, i)});
            }
            else
            {
                switch(property.constructor)
                {
    
                    case String:
                        panel.addString(i, property, {callback: function(i,v)
                        {
                            this.properties[i] = v;
                        }.bind(this, i)});
                        break;
                    case Number:
                        if(i=="amount")
                        {
                            panel.addNumber(i, property, {min:0, max:1,callback: function(i,v)
                            {
                                this.properties[i] = v;
                            }.bind(this,i)});
                        }
                        else{
                            panel.addNumber(i, property, {callback: function(i,v)
                            {
                                if(i=="start")
                                {
                                    var dt = v - this.properties[i];
                                    this.properties.ready += dt;
                                    this.properties.strokeStart += dt;
                                    this.properties.stroke += dt;
                                    this.properties.strokeEnd += dt;
                                    this.properties.relax += dt;
                                }
                                this.properties[i] = v;
                            }.bind(this,i)});
                        }
                        break;
                    case Boolean:
                        panel.addCheckbox(i, property, {callback: function(i,v)
                        {
                            this.properties[i] = v;
                        }.bind(this,i)});
                            break;
                    case Array:
                        panel.addArray(i, property, {callback: function(i,v)
                        {
                            this.properties[i] = v;
                        }.bind(this,i)});
                            break;
                }
            }
        }
    }
    
    //HeadDirectionShiftClip
    HeadDirectionShiftClip.type = "headDirectionShift";
    function HeadDirectionShiftClip()
    {
        this.id= "headDir-"+Math.ceil(getTime());
        this.properties = {target : ""}
        this.start = 0;
        this.duration = 0.5;
    
        this._width = 0;
    
        this.color = "black";
        this.font = "40px Arial";
    
    }
    
    HeadDirectionShiftClip.id = ANIM.HEADDIRECTION? ANIM.HEADDIRECTION:8;
    HeadDirectionShiftClip.clip_color = "orange";
    ANIM.registerClipType( HeadDirectionShiftClip );
    
    HeadDirectionShiftClip.prototype.toJSON = function()
    {
        var json = {
            id: this.id,
            target: this.properties.target,
            start: this.start,
            duration: this.duration,
        }
    
        return json;
    }
    
    HeadDirectionShiftClip.prototype.fromJSON = function( json )
    {
        this.id = json.id;
        this.properties.target = json.target;
        this.start = json.start;
        this.duration = json.duration;
    }
    
    HeadDirectionShiftClip.prototype.drawTimeline = function( ctx, project, w,h, selected )
    {
        ctx.globalCompositeOperation =  "source-over";
        var text_info = ctx.measureText( this.id );
        ctx.fillStyle = this.color;
        if( text_info.width < (w - 24) )
            ctx.fillText( this.id, 24,h * 0.7 );
    }
    /*----------------------------------Posture Behaviour-----------------------------------*/
    //PostureClip
    PostureClip.type = "posture";
    function PostureClip()
    {
        this.id= "posture-"+Math.ceil(getTime());
    
        this.start = 0;
        this.duration = 1;
    
        this._width = 0;
    
        this.properties = {
            lexeme : "", //[ARMS_CROSSED,...]
            part : "", //[ARMS, LEFT_ARM, RIGHT_ARM, LEGS...]
            stance : "", //[SITTING, CROUNCHING, STANDING, LYING]
            ready : 0.25, //if it's not permanent
            relax : 0.75, //if it's not permanent
        /*	permanent : false,*/
        }
        this.color = "black";
        this.font = "40px Arial";
    
    }
    
    PostureClip.id = ANIM.POSTURE? ANIM.POSTURE:9;
    PostureClip.clip_color = "#7CFF00";
    ANIM.registerClipType( PostureClip );
    
    PostureClip.prototype.toJSON = function()
    {
        var json = {
            id: this.id,
            start: this.start,
            duration: this.duration,
        }
        for(var i in this.properties)
        {
            json[i] = this.properties[i];
        }
        return json;
    }
    
    PostureClip.prototype.fromJSON = function( json )
    {
        this.id = json.id;
        this.properties.lexeme = json.lexeme;
        this.properties.part = json.part;
        this.properties.stance = json.stance;
        this.start = json.start;
        this.properties.ready = json.ready;
        this.properties.relax = json.relax;
        this.duration = json.duration;
        /*this.properties.permanent = json.permanent;*/
    }
    
    PostureClip.prototype.drawTimeline = function( ctx, project, w,h, selected )
    {
        ctx.globalCompositeOperation =  "source-over";
        var text_info = ctx.measureText( this.id );
        ctx.fillStyle = this.color;
        if( text_info.width < (w - 24) )
            ctx.fillText( this.id, 24,h * 0.7 );
    }
    
    /*-------------------------Speech Behaviour---------------------------------*/
    //Speech to show captions
    SpeechClip.type = "speech";
    function SpeechClip()
    {
        this.id = "speech-"+ Math.ceil(getTime());
        this.start = 0
        this.duration = 5;
    
        this._width = 0;
    
        this.properties = {inherited_text:false, text : ""}
        this.aduioId = null;
        this.color = "black";
    
      this.clip_color = "#94e9d9";
      //this.icon_id = 37;
    }
    
    SpeechClip.id = ANIM.SPEECH;
    SpeechClip.clip_color = "#FF0046";
    ANIM.registerClipType( SpeechClip );
    
    
    SpeechClip.prototype.toJSON = function()
    {
        var json = {
            id: this.id,
            start: this.start,
            duration: this.duration,
        }
        for(var i in this.properties)
        {
            json[i] = this.properties[i];
        }
        return json;
    }
    
    SpeechClip.prototype.fromJSON = function( json )
    {
        this.id = json.id;
        this.start = json.start;
        this.duration = json.duration;
        this.properties.text = json.text;
        if(this.properties.inherited_text)
            this.properties.inherited_text = json.inherited_text;
        if(json.audioId)
            this.audioId = json.audioId;
    }
    
    SpeechClip.prototype.drawTimeline = function( ctx, project, w,h, selected )
    {
        if(this.id == "")
            this.id = this.text;
        var text_info = ctx.measureText( this.id );
        ctx.fillStyle = this.color;
    /*	if( text_info.width < (w - 24) )*/
            ctx.fillText( this.id, 24,h * 0.7 );
    }
    SpeechClip.prototype.showInfo = function(panel)
    {
        for(var i in this.properties)
        {
            var property = this.properties[i];
            if(i=="text"){
                if(this.properties['inherited_text']==false)
                {
                    var newPhrase = "";
                    var tags = [];
                    var textarea = panel.addTextarea(i, property,{title:"Custom text", callback: function(v, value)
                        {
                            this.properties[i] = value;
                    }.bind(this, i)});
                    textarea.id = "custom-textarea";
                    textarea.addEventListener("keypress", function(e){
                        var that = this;
                        /*if(e.key=="Alt"||e.key=="AltGraph" || e.key=="Control"|| e.key=="CapsLock" || e.key=="Backspace")
                          return;*/
                        newPhrase =   textarea.getValue();
                        if(e.key == "#"){
                            autocomplete(textarea, EntitiesManager.getEntities(), tags, {})
                            //displayEntity(i, phrase, e, tags)
                            newPhrase = e.target.value;
                        }
                        textarea.setValue( newPhrase );
                    }.bind(this));
                    continue;
                }
            }
            if(i=="inherited_text")
            {
                var that = this;
                panel.addCheckbox(i, property, {title:"Text from the parent node", id:"inher", callback: function(v)
                {
                    that.properties["inherited_text"] = v;
                    var text_area = null
                    for(var i in this.parentElement.children )
                        if(this.parentElement.children[i].id == "custom-textarea")
                            text_area = this.parentElement.children[i]
                    
                    if(v)
                        text_area.style.visibility = "hidden";
                    else
                        text_area.style.visibility = "visible";
                }});
                continue;
            }
            else
            {
                switch(property.constructor)
                {
    
                    case String:
                        
                        panel.addString(i, property, {callback: function(i,v)
                        {
                            this.properties[i] = v;
                        }.bind(this, i)});
                        
                        break;
                    case Number:
                        if(i=="amount")
                        {
                            panel.addNumber(i, property, {min:0, max:1,callback: function(i,v)
                            {
                                this.properties[i] = v;
                            }.bind(this,i)});
                        }
                        else
                        {
                            panel.addNumber(i, property, {callback: function(i,v)
                            {
                                this.properties[i] = v;
                            }.bind(this,i)});
                        }
                        break;
                    case Boolean:
                        panel.addCheckbox(i, property, {callback: function(i,v, panel)
                        {
                            this.properties[i] = v;
                        }.bind(this,i)});
                            break;
                    case Array:
                        panel.addArray(i, property, {callback: function(i,v)
                        {
                            this.properties[i] = v;
                        }.bind(this,i)});
                            break;
                }
            }
        }
    }
    
    function BaseClip()
    {
    }
    
    BaseClip.prototype.getProject = function()
    {
        if(!this._track)
            return null;
        return this._track._project;
    }
    
    BaseClip.prototype.addControlChannel = function(name, type)
    {
        if(!this.control_channels)
            this.control_channels = [];
        var cc = new ANIM.ControlChannel();
        cc.name = name;
        cc.type = type;
        this.control_channels.push(cc);
        return cc;
    }
    
    //returns value of a CC given a local_time
    BaseClip.prototype.getCC = function(name, time, default_value )
    {
        if(!this.control_channels)
            return default_value;
    
        for(var i = 0; i < this.control_channels.length;++i)
        {
            var cc = this.control_channels[i];
            if( cc.name != name )
                continue;
            //sample value
            var prev = null;
            var next = null;
            for(var j = 0; j < cc.values.length; ++j)
            {
                var v = cc.values[j];
                if(v[0] < time)
                {
                    prev = v;
                    continue;
                }
                next = v;
                break;
            }
    
            if(!prev && !next)
                return 0; //no data
    
            if(!prev && next)
                return next[1];
    
            if(prev && !next)
                return prev[1];
    
            var f = (time - prev[0]) / (next[0] - prev[0]);
            if(cc.type == ANIM.NUMBER)
                return prev[1] * (1-f) + next[1] * (f);
        }
    
        return default_value;
    }
    
    
    
    //AudioClip to playback audios ******************************
    function AudioClip()
    {
        /** 
         * 
         * 
        this.id = "speech-"+ Math.ceil(getTime());
        this.start = 0
        this.duration = 5;
        this._width = 0;
        this.properties = {text : ""}
        this.aduioId = null;
        this.color = "black";
          this.clip_color = "#94e9d9";
        */
    
    
        this._src = "";
        this.id = "audio-"+ Math.ceil(getTime());
        this.start = 0;
        this.duration = 1;
        this.volume = 0.5;
        this.offset_time = 0;
        this.properties = {url:"", text:""}
        this.position = new Float32Array(2);
        this.scale = new Float32Array([1,1]);
        this.clip_color = "#7c0022";
        this.color = "white";
        if(typeof(Audio) == "function")
        {
            this._audio = new Audio()
            this._audio.onloadedmetadata = function(v){this.duration = this._audio.duration}.bind(this)
        }
        else
            this._audio	 = {};
        
    }
    AudioClip.type = "lg"
    AudioClip.id = ANIM.AUDIO;
    AudioClip.clip_color = "#7c0022";
    
    Object.defineProperty( AudioClip.prototype, "src", {
        set: function(v){
            
            this._src = v;
            this._audio.src = v;
        },
        get: function(){
            return this._src;
        }
    });
    
    AudioClip.id = ANIM.AUDIO;
    ANIM.registerClipType( AudioClip );
    
    
    AudioClip.prototype.preload = function( time, is_visible )
    {
        if(!is_visible)
            this._audio.currentTime = this.offset_time;
    }
    
    AudioClip.prototype.drawTimeline = function( ctx, project, w,h, selected )
    {
        //draw waveform...
        if(this.id == "")
            this.id = this.text;
        var text_info = ctx.measureText( this.id );
        ctx.fillStyle = this.color;
        /*	if( text_info.width < (w - 24) )*/
        ctx.fillText( this.id, 24,h * 0.7 );
    }
    
    AudioClip.prototype.onLeave = function( project, player )
    {
        this._audio.volume = 0;
    }
    
    AudioClip.prototype.isLoading = function()
    {
        return this._audio.seeking;
    }
    
    AudioClip.prototype.toJSON = function()
    {
        var json = {
            id: this.id,
            start: this.start,
            duration: this.duration,
        }
        for(var i in this.properties)
        {
            json[i] = this.properties[i];
        }
        return json;
    }
    
    AudioClip.prototype.fromJSON = function(json)
    {
        this.id = json.id;
        this.start = json.start;
        this.duration = json.duration;
        this.properties.url = json.url;
        this.properties.text = json.text;
        if(json.audioId)
            this.audioId = json.audioId;
    }
    
    AudioClip.prototype.showInfo = function(panel)
    {
        for(var i in this.properties)
        {
            var property = this.properties[i];
    
            switch(property.constructor)
            {
                
                case String:
                    if(i == "url")
                    {
                        panel.addString(i, property, {callback: function(i,v)
                            {
                                this._audio.src = v;
                                if(this._src != v)
                                    this._audio.load();
                                this.properties[i] = v;
                                this._src = v;
                                
                            }.bind(this, i)});
                    }
                    else{
                        panel.addString(i, property, {callback: function(i,v)
                            {
                                this.properties[i] = v;
                            }.bind(this, i)});
                    }
                    
                    break;
                case Number:
                    if(i=="amount")
                    {
                        panel.addNumber(i, property, {min:0, max:1,callback: function(i,v)
                        {
                            this.properties[i] = v;
                        }.bind(this,i)});
                    }
                    else
                    {
                        panel.addNumber(i, property, {callback: function(i,v)
                        {
                            this.properties[i] = v;
                        }.bind(this,i)});
                    }
                    break;
                case Boolean:
                    panel.addCheckbox(i, property, {callback: function(i,v, panel)
                    {
                        this.properties[i] = v;
                    }.bind(this,i)});
                        break;
                case Array:
                    panel.addArray(i, property, {callback: function(i,v)
                    {
                        this.properties[i] = v;
                    }.bind(this,i)});
                        break;
            }
        }
        
    }
    
    //helpers **************************
    
    var seed = 123;
    function random() {
        var x = Math.sin(seed++) * 10000;
        return x - Math.floor(x);
    }
    var noise_data = new Float32Array(1024);
    for(var i = 0; i < noise_data.length; ++i)
        noise_data[i] = random();
    
    function noise(t)
    {
        var i = (t|0) % 1024;
        if(i < 0) i = 1024 + i;
        var i2 = (i+1) % 1024;
        var f = t-(t|0);
        f = f*f*f*(f*(f*6.0-15.0)+10.0); //exp
        return noise_data[i] * (1-f) + noise_data[i2] * f;
    }
    
    ANIM.noise = noise;
    
    function distance(a,b)
    {
        var x = b[0] - a[0];
        var y = b[1] - a[1];
        return Math.sqrt(x*x+y*y);
    }
    
    function vec2Length(x,y)
    {
        return Math.sqrt(x*x+y*y);
    }
    
    function replace(target, search, replacement) {
        return target.replace(new RegExp(search, 'g'), replacement);
    };
    if(getTime() == undefined)
        global.getTime = performance.now.bind(performance);
    
    
    function RGB(r,g,b) { return "rgb(" + Math.floor(Math.clamp(r,0,1)*255) + "," + Math.floor(Math.clamp(g,0,1)*255) + "," + Math.floor(Math.clamp(b,0,1)*255) + ")"; }
    function HSL(h,s,L) { return "hsl(" + Math.floor(h*360) + "," + Math.floor(Math.clamp(s,0,1)*100) + "%," + Math.floor(Math.clamp(v,0,1)*100) + "%)"; }
    global.RGB = RGB;
    global.HSL = HSL;
    
    
})(this);
    
 (function _behaviourNodes(global)
 {
 
    let entitiesManager = new EntitiesManager();
    UTILS = global.UTILS;
   
   function ParseCompare(){
      this.shape = 2;
      var w = 150;
      var h =45;
  
      this.color="#64a003";
      this.background = "#85d603";
  
      this.input_contexts = [];
      this.output_contexts = [];
      this.visible_phrases = [];
      this.phrases =  [];
  
      this.addInput("","path", { pos:[w*0.5, - LiteGraph.NODE_TITLE_HEIGHT], dir:LiteGraph.UP});
      this.addOutput("","path", { pos:[w*0.5, h] , dir:LiteGraph.DOWN});
  
      this.widgets_up = true;
      this.size = [w,h];
      this.behaviour = new Behaviour();
  
      this.tags_outputs = {};
  
      this.EntitiesManager = entitiesManager;
  }
  
  //mapping must has the form [vocabulary array, mapped word]
   ParseCompare.prototype.onConfigure = function(o){
       if(o.phrases)
           this.phrases = o.phrases;
       if(o.visible_phrases)
           this.visible_phrases = o.visible_phrases;
       if(o.input_contexts)
           this.input_contexts = o.input_contexts;
       if(o.output_contexts)
           this.output_contexts = o.output_contexts;
   }
  
   ParseCompare.prototype.onSerialize = function(o){
       if(this.phrases)
           o.phrases = this.phrases;
       if(this.visible_phrases)
           o.visible_phrases = this.visible_phrases;
       if(this.input_contexts)
           o.input_contexts = this.input_contexts;
       if(this.output_contexts)
           o.output_contexts = this.output_contexts;
   }
  
   ParseCompare.prototype.tick = function(agent, dt, info){
       var text = "";
 
       for(var i in this.inputs){
           if(this.inputs[i].name == "text")
           text = this.getInputData(i);
       }
       if((!text || text == "") && info && info.text)
           text = info.text
       var training_phrases = this.phrases;
       text = text.toString();
 
       var found = this.compare(text, training_phrases);
       if(!found){
       //some of its children of the branch is still on execution, we break that execution (se weh we enter again, it starts form the beginning)
           if(this.running_node_in_banch)
           agent.bt_info.running_node_index = null;
 
           this.behaviour.STATUS = STATUS.fail;
           return this.behaviour;
     }
     else{
           var values = found;
           if(found.tags.length)
               values = this.extractEntities(text, found.tags);
           if(Object.keys(values).length){
               //Set tag outputs if any
               for(var o in this.outputs){
                   var output = this.outputs[o];
                   if(output.type == "string" && values[output.name]){
                   this.setOutputData(o, values[output.name]);
                   }
               }
               this.graph.context.blackboard.apply({entities:values})
               if(info){
                   if(!info.tags)
                       info.tags = {};
                   for(var i in values){
                       info.tags[i] = values[i];
                   }
               }
               else
                   info = {tags: values, text: info.text}
               
               //this.description = this.properties.property_to_compare + ' property passes the threshold';
               var children = this.getOutputNodes(0);
               //Just in case the conditional is used inside a sequencer to accomplish several conditions at the same time
               if(children.length == 0){
                   this.behaviour.type = B_TYPE.parseCompare;
                   this.behaviour.STATUS = STATUS.success;
                   return this.behaviour;
               }
 
               for(let n in children){
                   var child = children[n];
                   var value = child.tick(agent, dt, info);
                   if(value && value.STATUS == STATUS.success){
                       agent.evaluation_trace.push(this.id);
                       /* MEDUSA Editor stuff, not part of the core */
                       if(agent.is_selected)
                           highlightLink(this, child);
 
                       return value;
                   }
                   else if(value && value.STATUS == STATUS.running){
                       agent.evaluation_trace.push(this.id);
                       /* MEDUSA Editor stuff, not part of the core */
                       if(agent.is_selected)
                           highlightLink(this, child)
 
                       return value;
                   }
               }
           }
           var idx = this.outputs.indexOf(["text","string"]);
           if(idx>-1)
               this.setOutputData(idx,text)
           if(this.running_node_in_banch)
               agent.bt_info.running_node_index = null;
 
           this.behaviour.STATUS = STATUS.fail;
           return this.behaviour;
     }
       //this.setOutputData(0, values);
   }
 
   ParseCompare.prototype.compare = function (inputString, vocabulary){
       
       var data = {tags:[]};
       for (var i in vocabulary){
           var found = false;
           var currentVocab = vocabulary[i]
           var currentText = currentVocab.text;
           found = new RegExp(currentVocab.toCompare.toLowerCase()).test(inputString.toLowerCase());
 
           if (found){
               if(currentVocab.tags.length)
                   for(var t=0; t<currentVocab.tags.length; t++)
                       data.tags.push(currentVocab.tags[t]);
               else return currentVocab;
           }
               //return currentVocab;
       }
       return data.tags.length? data : false;
   }
   ParseCompare.prototype.extractEntities = function(string, tags){
       var info = {};
       for(var j = 0; j<tags.length; j++){
           var tag = tags[j];
           var value = this.EntitiesManager.getEntity(string, tag);
           if(!value)
               continue;
           info[tag] = value;
       }
       return info;
   }
  
   function wordInString(s, word){
       return new RegExp( '\\b' + word + '\\b', 'i').test(s);
   }
 
   ParseCompare.prototype.onGetInputs = function(){
       return [["text", "string", { pos: [0,this.size[1]*0.5], dir:LiteGraph.LEFT}]];
   }
  
   ParseCompare.prototype.onGetOutputs = function(){
       var outputs = [["text","string"]];
       for(var i in this.tags_outputs)
           outputs.push([i, this.tags_outputs[i]]);
       return outputs;
   }
  
   ParseCompare.prototype.onDeselected = function (){
     var parent = this.getInputNode(0);
     if(parent)
       parent.onDeselected();
   }
 
   ParseCompare.prototype.onShowNodePanel = function( event, pos, graphcanvas ){
       return true; //return true is the event was used by your node, to block other behaviours
   }
 
   LiteGraph.registerNodeType("btree/ParseCompare", ParseCompare );
 
   //EventNode.TYPES Deprecated, only used for ParseEvent and probably it will not work due to changes on HBT event execution
   EventNode.TYPES = ["userText", "imageRecieved","faceDetected", "infoRecieved"] //has to be sorted as EVENTS object idx
   /*textRecieved: 0,
   imageRecieved: 1,
   faceDetected: 2,
   codeRecieved: 3*/
  
   /**
   * EventNode
   * Node that stops graph flow until a matching event is received
   * An event match if it contains class.property in its data (* means any)
   */
   function EventNode(){
       this.shape = 1
       this.color = "#1E1E1E"
       this.boxcolor = "#999";
       this.addOutput("","path");
       this.properties = {};
       this.horizontal = true;
       this.widgets_up = true;
       this.addProperty("type", "user.text");
 
       this.widgetType = this.addWidget("string", "type", this.properties.type, function(v){this.properties.type = v;}.bind(this));
 
       this.addInput("", "path");
       this.behaviour = new Behaviour();
   }
  
   EventNode.prototype.onAdded = function(){
       this.title = "Event "+this.id;
       //this.widgetId = this.addWidget("info","id", this.properties.id, null, {editable:false});
   }
 
   //Does not get called
   EventNode.prototype.onPropertyChanged = function(name, value){
       if(name == "type"){
           this.widgetType.value = this.properties.type = value;
       }
   }
 
   EventNode.prototype.tick = function(agent, dt, info){
       if(this.graph.context.last_event_node!=this.id){
           this.graph.context.last_event_node = this.id;
           return {STATUS : STATUS.success};
       }
 
     var children = this.getOutputNodes(0);
     for(var n in children) {
 
       var child = children[n];
       //if(child.constructor.name == "Subgraph")
       //child = child.subgraph.findNodeByTitle("HBTreeInput");
           
           if(this.data)
           {
               if(info){
               
                   for(var i in this.data)
                   {
                       info[i] = this.data[i];
                   }
                   
               }
               else if(this.data)
                   info = Object.assign({},this.data);
           
               value = child.tick(agent, dt, info);
           }
           else
               var value = child.tick(agent, dt);
 
       if(value && (value.STATUS == STATUS.success || value.STATUS == STATUS.running)) {
 
         if(agent.is_selected)
           highlightLink(this, child)
         //push the node_id to the evaluation trace
         agent.evaluation_trace.push(this.id);
 
         //know if bt_info params must be reset
         //if the node was not in the previous
         // if(!nodePreviouslyEvaluated(agent, this.id))
         // 	resetHBTreeProperties(agent)
 
         return value;
       }
     }
       
       if(this.outputs)
       {
           for(var i = 0; i < this.outputs.length; i++)
           {
               if(this.outputs[i][0] == this.properties.type && this.data)
                   this.setOutputData(i, this.data)
           }
       }
 
     // if(this.running_node_in_banch)
     // 	agent.bt_info.running_node_index = null;
 
     this.behaviour.STATUS = STATUS.fail;
     return this.behaviour;
   }
 
   EventNode.prototype.onConfigure = function(info){
     onConfig(info, this.graph);
     //["userText", "imageRecieved","faceDetected", "infoRecieved"]
     if(this.properties.type == "userText") this.properties.type = "user.text";
     this.widgetType.value = this.properties.type;
   }
 
   EventNode.title = "Event";
   EventNode.desc = "Event node of the Hybrid Behaviour Tree";
 
   //reorder the links
   EventNode.prototype.onStart = EventNode.prototype.onDeselected = function(){
     var children = this.getOutputNodes(0);
     if(!children) return;
     children.sort(function(a,b){
       if(a.pos[0] > b.pos[0])
         return 1;
       if(a.pos[0] < b.pos[0])
         return -1;
     });
 
     this.outputs[0].links = [];
     for(var i in children)
       this.outputs[0].links.push(children[i].inputs[0].link);
   }
   EventNode.prototype.onGetOutputs = function()
   {
       return [[this.properties.type,"*", {dir:LiteGraph.LEFT}]]
   }
   /*EventNode.prototype.onGetOutputs = function(){
       var outputs = [];
       for(var i in this.data)
       {
           outputs.push([i, typeof(this.data[i])]);
       }
       return outputs;
   }*/
 
   LiteGraph.registerNodeType("btree/Event", EventNode);
 
   /**
   * ParseEvent
   * (Old) Event and ParseCompare in the same node
   * Event part not updated to new class.property event definition
   */
   //TODO ParseEvent not updated to new events!
   /*
   function ParseEvent(){
       this.shape = 2
       this.color = "#1E1E1E"
       this.boxcolor = "#999";  // this.boxcolor = "#999";
       this.addOutput("","path");
       this.properties = {};
       this.horizontal = true;
       this.widgets_up = true;
       this.addProperty("type", EventNode.TYPES[0]);
 
       this.event_type = EVENTS.textRecieved;
       var that = this;
       this.widgetType = this.addWidget("combo","type", that.properties.type, function(v){that.properties.type = v},  {values: EventNode.TYPES});
       
       this.input_contexts = [];
       this.output_contexts = [];
       this.visible_phrases = [];
       this.phrases =  [];
       
       this.addInput("", "path");
       this.behaviour = new Behaviour();
   }
 
   ParseEvent.prototype.onConfigure = function(o){
       if(o.phrases)
           this.phrases = o.phrases;
       if(o.visible_phrases)
           this.visible_phrases = o.visible_phrases;
       if(o.input_contexts)
           this.input_contexts = o.input_contexts;
       if(o.output_contexts)
           this.output_contexts = o.output_contexts;
   }
 
   ParseEvent.prototype.onSerialize = function(o){
       if(this.phrases)
           o.phrases = this.phrases;
       if(this.visible_phrases)
           o.visible_phrases = this.visible_phrases;
       if(this.input_contexts)
           o.input_contexts = this.input_contexts;
       if(this.output_contexts)
           o.output_contexts = this.output_contexts;
   }
 
   ParseEvent.prototype.onAdded = function(){
       this.title = "ParseEvent "+this.id;
       //this.widgetId = this.addWidget("info","id", this.properties.id, null, {editable:false});
   }
 
   ParseEvent.prototype.onPropertyChanged = function(name, value){
       if(name == "type"){
         this.event_type = EventNode.TYPES.indexOf(value);
       }
   }
 
   ParseEvent.prototype.onStart = EventNode.prototype.onDeselected = function(){
     var children = this.getOutputNodes(0);
     if(!children) return;
     children.sort(function(a,b){
       if(a.pos[0] > b.pos[0])
         return 1;
 
       if(a.pos[0] < b.pos[0])
         return -1;
 
     });
 
     this.outputs[0].links = [];
     for(var i in children)
       this.outputs[0].links.push(children[i].inputs[0].link);
   }
 
   ParseEvent.prototype.tick = function(agent, dt){
       if(this.graph.context.last_event_node!=this.id){
           this.graph.context.last_event_node = this.id;
           return {STATUS : STATUS.success};
       }
       var text = "";
       for(var i in this.inputs){
           if(this.inputs[i].name == "text")
           text = this.getInputData(i);
       }
 
       if((!text || text == "") && this.data && this.data.text)
           text = this.data.text;
     var training_phrases = this.phrases;
 
       var found = this.compare(text, training_phrases);
 
       if(!found){
       //some of its children of the branch is still on execution, we break that execution (se weh we enter again, it starts form the beginning)
           if(this.running_node_in_banch)
           agent.bt_info.running_node_index = null;
 
           this.behaviour.STATUS = STATUS.fail;
           return this.behaviour;
     }
       else{
           var values = this.extractEntities(text, found.tags);
           if(values){
               var info = {tags: values}
 
               //this.description = this.properties.property_to_compare + ' property passes the threshold';
               var children = this.getOutputNodes(0);
               //Just in case the conditional is used inside a sequencer to accomplish several conditions at the same time
               if(children.length == 0){
                   this.behaviour.type = B_TYPE.parseCompare;
                   this.behaviour.STATUS = STATUS.success;
                   return this.behaviour;
               }
 
               for(let n in children){
                   var child = children[n];
                   var value = child.tick(agent, dt, info);
                   if(value && value.STATUS == STATUS.success){
                       agent.evaluation_trace.push(this.id);
                       //MEDUSA Editor stuff, not part of the core
                       if(agent.is_selected)
                           highlightLink(this, child);
 
                       return value;
                   }
                   else if(value && value.STATUS == STATUS.running){
                       agent.evaluation_trace.push(this.id);
                       //MEDUSA Editor stuff, not part of the core
                       if(agent.is_selected)
                           highlightLink(this, child)
 
                       return value;
                   }
               }
           }
 
           if(this.running_node_in_banch)
               agent.bt_info.running_node_index = null;
 
           this.behaviour.STATUS = STATUS.fail;
           return this.behaviour;
     }
   }
 
   ParseEvent.prototype.compare = function (inputString, vocabulary){
       var found = false;
       for (var i in vocabulary) {
           var currentVocab = vocabulary[i]
           var currentText = currentVocab.text;
           found = new RegExp(currentVocab.toCompare.toLowerCase()).test(inputString.toLowerCase());
           
           if (found)
               return currentVocab;
       }
       return found;
   }
 
   ParseEvent.prototype.extractEntities = function(string, tags){
       var info = {};
       for(var j = 0; j<tags.length; j++){
           var tag = tags[j];
           var value = EntitiesManager.getEntity(string, tag);
           if(!value)
               return false;
           info[tag] = value;
       }
       return info;
   }
 
   ParseEvent.prototype.onGetInputs = function(){
       return [["text", "string", { pos: [0,this.size[1]*0.5], dir:LiteGraph.LEFT}]];
   }
 
   ParseEvent.prototype.onDeselected = function (){
     var parent = this.getInputNode(0);
     if(parent)
       parent.onDeselected();
   }
 
   ParseEvent.prototype.onShowNodePanel = function( event, pos, graphcanvas ){
       return true; //return true is the event was used by your node, to block other behaviours
   }
 
   LiteGraph.registerNodeType("btree/ParseEvent", ParseEvent);
   */
 
   /**
   * TriggerNode
   * Sets next node to be called to the specified node id
   */
   function TriggerNode(){
     this.shape = 1;
     this.color = "#1E1E1E"
     this.boxcolor = "#999";
 
     this.properties = {node_id:null};
     this.horizontal = true;
     this.widgets_up = true;
 
     this.addProperty("node_id", "");
     var that = this;
     this.widget = this.addWidget("string","node_id", this.properties.node_id, function(v){v = v.replace("Event ", ""); that.properties.node_id = v;});
     this.addInput("", "path");
     this.serialize_widgets = true;
     this.behaviour = new Behaviour();
   }
 
   TriggerNode.prototype.tick = function(agent, dt, info){
       if(this.graph._is_subgraph)
           this.graph._subgraph_node.graph.context.last_event_node = this.properties.node_id;
       else
           this.graph.context.last_event_node = this.properties.node_id;
       return {STATUS : STATUS.success};
   }
 
   TriggerNode.prototype.onConfigure = function(info){
       onConfig(info, this.graph);
   }
 
   LiteGraph.registerNodeType("btree/Trigger", TriggerNode);
 
   /**
   * HBTreeInput
   * Input of a behaviour subgraph that passes the path into the graph
   */
   function HBTreeInput(){
       this.name_in_graph = "";
       this.properties    = {
           name: "root",
           type: "path",
           value: 0
       };
       this._node    = null;
       this.shape    = 2;
       this.color    = "#1E1E1E"
       this.boxcolor = "#999";
       this.addOutput("","path");
       this.horizontal = true;
       this.widgets_up = true;
     this.behaviour  = new Behaviour();
       this.serialize_widgets = true;
   }
 
   HBTreeInput.title = "HBTreeInput";
   HBTreeInput.desc = "Input of a behaviour subgraph that passes the path into the graph";
 
   HBTreeInput.prototype.onAdded = function(){
       if(this.graph){
           if(!this.graph._subgraph_node.inputs || this.graph._subgraph_node.inputs.length == 0){
               this.graph.addInput( this.properties.name, this.properties.type );
               this.graph.description_stack = [];
           }
       }
   }
 
   HBTreeInput.prototype.tick = function(agent, dt, info){
 
     var children = this.getOutputNodes(0);
     for(var n in children){
       var child = children[n];
       var value = child.tick(agent, dt, info);
       if(value && value.STATUS == STATUS.success){
         if(agent.is_selected)
           highlightLink(this,child)
 
         return value;
       }
       else if(value && value.STATUS == STATUS.running){
         this.running_node_in_banch = true;
         if(agent.is_selected)
           highlightLink(this,child)
 
         return value;
       }
     }
     this.behaviour.STATUS = STATUS.fail;
     return this.behaviour;
   }
 
   HBTreeInput.prototype.getTitle = function(){
       if (this.flags.collapsed)
           return this.properties.name;
 
       return this.title;
   }
 
   HBTreeInput.prototype.onAction = function( action, param ){
       if (this.properties.type == LiteGraph.EVENT)
           this.triggerSlot(0, param);
   }
 
   HBTreeInput.prototype.onExecute = function(){
       //read from global input
       var name = this.properties.name;
       var data = this.graph.inputs[name];
       if (!data)
       {
           this.setOutputData(0, this.properties.value );
           return;
       }
 
       this.setOutputData(0, data.value !== undefined ? data.value : this.properties.value );
   }
 
   HBTreeInput.prototype.onRemoved = function(){
       if (this.name_in_graph)
           this.graph.removeInput(this.name_in_graph);
   }
 
   HBTreeInput.prototype.onStart = HBTreeInput.prototype.onDeselected = function(){
     var children = this.getOutputNodes(0);
     if(!children) return;
     children.sort(function(a,b){
       if(a.pos[0] > b.pos[0])
         return 1;
       if(a.pos[0] < b.pos[0])
         return -1;
     });
 
     this.outputs[0].links = [];
     for(var i in children)
       this.outputs[0].links.push(children[i].inputs[0].link);
 
     var parent = this.getInputNode(0);
     if(parent)
       parent.onDeselected();
   }
 
   LiteGraph.HBTreeInput = HBTreeInput;
   LiteGraph.registerNodeType("graph/HBTreeinput", HBTreeInput);
 
   /**
   * HBTreeOutput
   * Output of a behaviour subgraph that passes the path into the parent graph
   */
   function HBTreeOutput(){
       this.name_in_graph = "";
       this.properties    = {
           name: "root",
           type: "path",
           value: 0
       };
       var that      = this;
       this._node    = null;
       this.shape    = 2;
       this.color    = "#1E1E1E"
       this.boxcolor = "#999";
       this.addInput("","path");
       this.horizontal = true;
       this.widgets_up = true;
     this.behaviour  = new Behaviour();
       this.serialize_widgets = true;
   }
 
   HBTreeOutput.title = "HBTreeOutput";
   HBTreeOutput.desc  = "Output of a behaviour subgraph that passes the path into the parent graph";
 
   HBTreeOutput.prototype.onAdded = function(){
       if(this.graph){
           if( this.graph._subgraph_node.outputs == undefined || this.graph._subgraph_node.outputs.length == 0 ){
               this.graph.addOutput( this.properties.name, this.properties.type );
               this.graph.description_stack = [];
           }
       }
   }
 
   HBTreeOutput.prototype.tick = function( agent, dt ){
       if(this.graph && this.graph._subgraph_node){
           var children = this.graph._subgraph_node.getOutputNodes(0)
           // In case the subgraph is not connected in the output
           if(!children || children.length == 0){
               this.behaviour.STATUS = STATUS.fail;
               return this.behaviour;
           }
 
           for(var n in children){
               var child = children[n];
               var value = child.tick(agent, dt);
               if(value && value.STATUS == STATUS.success){
                   if(agent.is_selected)
                       highlightLink(this,child)
 
                   return value;
               }
               else if(value && value.STATUS == STATUS.running){
                   this.running_node_in_banch = true;
                   if(agent.is_selected)
                       highlightLink(this,child)
 
                   return value;
               }
           }
       }
       else{
           this.behaviour.STATUS = STATUS.fail;
           return this.behaviour;
       }
     this.behaviour.STATUS = STATUS.fail;
     return this.behaviour;
   }
  
   HBTreeOutput.prototype.getTitle = function(){
       if (this.flags.collapsed)
           return this.properties.name;
 
       return this.title;
   }
 
   HBTreeOutput.prototype.onAction = function( action, param ){
       if (this.properties.type == LiteGraph.EVENT)
           this.triggerSlot(0, param);
 
   }
 
   HBTreeOutput.prototype.onExecute = function(){
       //read from global input
       var name = this.properties.name;
       var data = this.graph.inputs[name];
       if (!data){
           this.setOutputData(0, this.properties.value );
           return;
       }
       this.setOutputData(0, data.value !== undefined ? data.value : this.properties.value );
   }
 
   HBTreeOutput.prototype.onRemoved = function(){
       if (this.name_in_graph){
           this.graph.removeInput(this.name_in_graph);
       }
   }
 
   HBTreeOutput.prototype.onStart = HBTreeOutput.prototype.onDeselected = function(){
       if(this.graph && this.graph._subgraph_node){
           var children = this.graph._subgraph_node.getOutputNodes(0)
 
           if(!children) return;
           children.sort(function(a,b){
               if(a.pos[0] > b.pos[0])
                   return 1;
               if(a.pos[0] < b.pos[0])
                   return -1;
           });
 
           this.graph._subgraph_node.outputs[0].links = [];
           for(var i in children)
               this.graph._subgraph_node.outputs[0].links.push(children[i].inputs[0].link);
 
           var parent = this.getInputNode(0);
           if(parent)
               parent.onDeselected();
       }
   }
 
   LiteGraph.HBTreeOutput = HBTreeOutput;
   LiteGraph.registerNodeType("graph/HBTreeOutput", HBTreeOutput);
 
   //-----------------------BEHAVIOUR NODES------------------------------------//
   //Return a Behaviour to be handled by the application
 
   /**
   * Intent
   * This node returns a B_TYPE.intent Behaviour with BML formatted information
   */
   function Intent(o){
       var w = 150;
       var h = 45;
 
       this.color="#64a003";
       this.background = "#85d603";
       this.addInput("","path", {pos:[w*0.5,-LiteGraph.NODE_TITLE_HEIGHT], dir:LiteGraph.UP});
 
 
       this.responses = [];
       this.visible_phrases = [];
       this.input_contexts = [];
 
       this.widgets_up = true;
 
       //this.addOutput("","path", { pos: [w*0.5, h-LiteGraph.NODE_TITLE_HEIGHT], dir:LiteGraph.DOWN});
       this.size = [w,h];
       this.behaviour = new Behaviour();
       /*if(o)
         this.configure(o);*/
   }
 
   Intent.prototype.onConfigure = function(o){
       if(o.responses)
           this.responses = o.responses;
 
       if(o.visible_phrases)
           this.visible_phrases = o.visible_phrases;
   }
 
   Intent.prototype.onSerialize = function(o){
       if(this.responses)
           o.responses = this.responses;
 
       if(this.visible_phrases)
           o.visible_phrases = this.visible_phrases;
   }
 
   Intent.prototype.tick = function(agent, dt, info){
     if(this.facade == null)
       this.facade = this.graph.context.facade;
 
       if(this.responses.length){
           return this.intent(agent,info);
     }
   }
 
   Intent.prototype.intent = function(agent, info){
       var id = Math.floor(Math.random()*this.responses.length);
       var response = this.responses[id];
       var output = response.text || "";
       if(response.tags.length>0 && info && info.tags){
           for(var i in response.tags){
               var tag = response.tags[i];
               if(info.tags[tag])
                 output = response.text.replace(tag, info.tags[tag]);
               else
                   output = response.text.replace(tag, "");
           }
       }
 
       var behaviour = {
       text: output,
       text_id: id,
       data: this.responses[id],
       author: "DaVinci"
       };
 
       this.behaviour.type = B_TYPE.intent || 16;
     this.behaviour.STATUS = STATUS.success;
     this.behaviour.setData(behaviour);
     //this.behaviour.priority = this.properties.priority;
     agent.evaluation_trace.push(this.id);
     this.graph.evaluation_behaviours.push(this.behaviour);
     return this.behaviour;
   }
 
   Intent.prototype.onDeselected = function (){
     var parent = this.getInputNode(0);
     if(parent)
       parent.onDeselected();
   }
 
   LiteGraph.registerNodeType("btree/Intent", Intent );
 
   //TODO Merge TimelineIntent from timeline_node.js here
   /**
   * TimelineIntent
   * This node returns a B_TYPE.timeline_intent Behaviour with BML formatted information
   */
   function TimelineIntent(o){
       var w = 150;
       var h =45;
       
       this.addInput("","path", { pos:[w*0.5, - LiteGraph.NODE_TITLE_HEIGHT], dir:LiteGraph.UP});
 
       this.properties = { precision: 1 };
       this.size = [w,h];
       this.shape = 2;
       this.horizontal = true;
       this.serialize_widgets = true;
       this.widgets_up = true;
 
       this.color= "#97A003";
       this.background = "#85d603";
 
       this.name = "Intent timeline";
 
       this.behaviour = new Behaviour();
 
       //timing
       this.current_time = 0;
       this.duration = 160;
       this.framerate = 30;
       this.type = ANIM.CANVAS2D;
       this.allow_seeking = true;
     
       //tracks: similar to layers
       this.tracks = []; //all tracks
       this.markers = []; //time markers
 
       if(!this.tracks.length){
           for(var i in ANIM.track_types){
               this.add(new ANIM.Track(i));
           }
       }
 
       TimelineIntent.instance = this;
   }
 
   //name to show
   TimelineIntent.title = "Timeline Intent";
   TimelineIntent.prototype.onConfigure = function(o){
       if(o.tracks){
           this.tracks = [];
           for(var i in o.tracks){
               var trackData = o.tracks[i];
               var track = new ANIM.Track(trackData.name);
               track.fromJSON(trackData);
               this.add(track);
           }
       }
 
       if(o.markers) this.markers = o.markers;
       this.duration = o.duration;
       this.current_time = o.current_time;
   }
 
   TimelineIntent.prototype.onSerialize = function(o){ 
       o.tracks = [];
       for(var i = 0; i < this.tracks.length; ++i) o.tracks.push(this.tracks[i].toJSON());
       o.markers = this.markers;
       o.duration = this.duration;
       o.current_time = this.current_time;
   }
 
   //function to call when the node is executed
   TimelineIntent.prototype.tick = function(agent, dt, info){
       if(this.facade == null)
           this.facade = this.graph.context.facade;
       var behaviours = [];
       var bml = {};
       for(var i in this.tracks){
           var track = this.tracks[i];
           if(!bml[track.name]&&track.clips.length){
               bml[track.name] = [];
           }
           for(var j in track.clips){
               if(track.clips[j].constructor==ANIM.SpeechClip){
                   if(track.clips[j].properties.inherited_text != undefined && track.clips[j].properties.inherited_text)
                   {
                       track.clips[j].properties.text = info.text || "Check out the development";
                   }
               }           
               var data = track.clips[j].toJSON();
               
               if(data.text)
               {               
                   var tags = data.text.replace(/[.,\/!$%\^&\*;:{}=\-_`~()]/g,"").match(/#\S+/g);
                   if(tags)
                   {  
                       var values = {};
                       for(var x=0; x<tags.length; x++)
                       {
                           var tag = tags[i];
                           if(info && info.tags !=undefined&& info.tags[tag])
                           {   
                               values[tag] = info.tags[tag];
                           }
                           else
                           {
                               var value = this.graph.context.blackboard.getValue("entities",tag)
                               if(value)
                                   values[tag] = value;
                           }
                           if(values[tag])
                               data.text = data.text.replace(tag, values[tag]);                             
                       }
                   }
               }
 
               data.type = track.clips[j].constructor.type;
               bml[track.name].push(data);
           }
       }
       
       for(var i in bml){
           var data = {};
           if(i.includes("Shift")){
               data.type = i;
               data.data = bml[i]
           }else{
               data = bml[i];
           }
           var behaviour = new Behaviour();
           behaviour.type = B_TYPE.timeline_intent || B_TYPE.intent;
           behaviour.STATUS = STATUS.success;
           behaviour.setData(data);
           behaviours.push(behaviour);
           this.graph.evaluation_behaviours.push(behaviour);
       }
       agent.evaluation_trace.push(this.id);
 
       return {STATUS:STATUS.success, data:behaviours};
   }
 
 
   TimelineIntent.prototype.add = function(track){
       if(track.constructor !== ANIM.Track) throw("only tracks allowed to be added to project");
       this.tracks.push( track );
       track._project = this;
       return track;
   }
   
   TimelineIntent.prototype.getTrack = function(id){
       if(id.constructor === String){
           for(var i = 0; i < this.tracks.length; ++i )
               if( this.tracks[i].name == id ) return this.tracks[i];
           return null;
       }
       return this.tracks[ Number(id) ];
   }
 
   TimelineIntent.prototype.clear = function( skip_default_tracks ){
       this.current_time = 0;
 
       this.globals = {};
       this.tracks.length = 0;
       this.markers.length = 0;
   }
 
 
   LiteGraph.registerNodeType("btree/TimelineIntent", TimelineIntent);
 
   /**
   * FacialExpression
   * This node returns a B_TYPE.facialExpression Behaviour with BML formatted gesture information
   * Deprecated, use Intent/TimelineIntent instead
   */
   FacialExpression.DURATION = ["Short-term", "Long-term"];
   FacialExpression.PRIORITY = ["append","overwrite", "mix", "skip"];
 
   function FacialExpression(){
       this.shape = 2;
     this.color = "#342331"
       this.bgcolor = "#523456";
     this.boxcolor = "#999";
     var w = 200;
       this.addInput("","path", {pos:[w*0.5,-LiteGraph.NODE_TITLE_HEIGHT], dir:LiteGraph.UP});
       this.size = [160,55];
       this.editable = { property:"value", type:"number" };
       this.widgets_up = true;
     //this.horizontal = true;
 
     this.gesture_list = ["Smile","Frown","Pout", "Pursed Lips", "Jaw Dropped", "Tongue Out", "Raise Eyebrow"];
     this.gesture_interface = ["smile_face","frown_face","pout_face", "pursed_lips", "jaw_dropped", "tongue_out", "raise_eyebrow"];
 
     this.addProperty("intensity", 0.5, "number", {min:0, max:1} );
     this.addProperty("priority", "append", "enum", {values: FacialExpression.PRIORITY});
     this.addProperty("gesture", this.gesture_list[0], "enum",{values: this.gesture_list});
     this.addProperty("duration", FacialExpression.DURATION[0], "enum", {values: FacialExpression.DURATION});
     this.addProperty("interface", this.gesture_interface[0], "enum", {values: this.gesture_interface});
     this.addProperty("keywords", "", "string");
 
       var that = this;
       this.widget = this.addWidget("combo","gesture", this.properties.gesture, this.onGestureChanged.bind(this),  {values: this.gesture_list});
       //this.number = this.addWidget("number","motion", this.properties.motion, function(v){ that.properties.motion = v; }, this.properties  );
       //this.toggle = this.addWidget("toggle","Translation:", this.properties.translation_enabled, function(v){ console.log(v);that.properties.translation_enabled = v; }, this.properties  );
     this.duration = this.addWidget("combo","duration", this.properties.duration, function(v){ that.properties.duration = v; },  {values: FacialExpression.DURATION} );
     this.addWidget("string","keywords", this.properties.keywords, function(v){ that.properties.keywords = v}, this.properties)
 
     this.facade = null;
     this.behaviour = new Behaviour();
     this.serialize_widgets = true;
   }
 
   FacialExpression.title = "FacialExpression";
 
   FacialExpression.prototype.onGestureChanged = function(v){
     var that = this;
     that.properties.gesture = v;
     var idx = that.gesture_list.findIndex(v);
     that.properties.gesture_interface = that.gesture_interface[idx];
   }
 
   FacialExpression.prototype.onDeselected = function(){
     var parent = this.getInputNode(0);
     if(parent)
       parent.onDeselected();
   }
 
   FacialExpression.prototype.tick = function(agent, dt){
     if(this.facade == null)
       this.facade = this.graph.context.facade;
 
     if(this.action){
       this.description = 'Facial expresison: ' + this.properties.gesture;
       this.action(agent);
     }
     this.graph.evaluation_behaviours.push(this.behaviour);
     return this.behaviour;
   }
 
   FacialExpression.prototype.action = function(){
     var behaviour = this.properties;
     this.behaviour.type = B_TYPE.facialExpression;
     this.behaviour.setData(behaviour);
   }
 
   FacialExpression.prototype.onExecute = function(){
     if(this.inputs.length>1){
       for(var i in this.inputs){
         var input = this.inputs[i];
         var idx = this.findInputSlot(input.name);
         switch(input.name){
           case "intensity":
             var value = this.getInputData(idx);
             this.properties.intensity = value;
             break;
           case "duration":
             var value = this.getInputData(idx);
             value = value.toLowerCase();
             if(value == "short-term" || value == "long-term")
               this.properties.duration = value;
             break;
         }
       }
     }
   }
 
   FacialExpression.prototype.onGetInputs =  function(){
     //this.horizontal = false;
     return [["intensity", "number", {dir:LiteGraph.LEFT, pos: [0, this.size[1]]}], ["duration", "string", {dir:LiteGraph.LEFT,  pos: [0, this.size[1]]}]];
   }
 
   FacialExpression.prototype.onInputAdded = function(v){
     if(v.name == "intensity" || v.name == "duration"){
       //this.addInput(v.name, v.type, {dir:LiteGraph.LEFT});
       var y = this.size[1];
 
       v.pos[1] = y+(this.inputs.length-2)*20;
       this.size[1] = v.pos[1]+10;
     }
 
   }
 
   LiteGraph.FacialExpression = FacialExpression;
   LiteGraph.registerNodeType("graph/FacialExpression", FacialExpression);
 
   /**
   * GestureNode
   * This node returns a B_TYPE.gestureNode Behaviour with BML formatted gesture information
   * Deprecated, use Intent/TimelineIntent instead
   */
   GestureNode.DURATION = ["Short-term", "Long-term"];
   GestureNode.PRIORITY = ["append","overwrite", "mix", "skip"];
 
   function GestureNode(){
       this.shape = 2;
     this.color = "#342331"
       this.bgcolor = "#523456";
     this.boxcolor = "#999";
     var w = 200;
       this.addInput("","path", {pos:[w*0.5,-LiteGraph.NODE_TITLE_HEIGHT], dir:LiteGraph.UP});
       this.size = [160,55];
       this.editable = { property:"value", type:"number" };
       this.widgets_up = true;
     //this.horizontal = true;
 
     //this.gesture_list = ["Smile","Frown","Pout", "Pursed Lips", "Jaw Dropped", "Tongue Out", "Raise Eyebrow"];
     //this.gesture_interface = ["smile_face","frown_face","pout_face", "pursed_lips", "jaw_dropped", "tongue_out", "raise_eyebrow"];
 
     this.addProperty("intensity", 0.5, "number", {min:0, max:1} );
     this.addProperty("priority", "append", "enum", {values: GestureNode.PRIORITY});
 
     this.addProperty("duration", GestureNode.DURATION[0], "enum", {values: GestureNode.DURATION});
     this.addProperty("interface", "", "string");
     this.addProperty("keywords", "", "string");
 
     var that = this;
     this.addWidget("string", "interface", this.properties.interface, function(v){ that.properties.interface = v; })
       //this.widget = this.addWidget("combo","gesture", this.properties.gesture, this.onGestureChanged.bind(this),  {values: this.gesture_list});
       //this.number = this.addWidget("number","motion", this.properties.motion, function(v){ that.properties.motion = v; }, this.properties  );
       //this.toggle = this.addWidget("toggle","Translation:", this.properties.translation_enabled, function(v){ console.log(v);that.properties.translation_enabled = v; }, this.properties  );
     this.duration = this.addWidget("combo","duration", this.properties.duration, function(v){ that.properties.duration = v; },  {values: GestureNode.DURATION} );
     this.addWidget("string","keywords", this.properties.keywords, function(v){ that.properties.keywords = v}, this.properties)
 
     this.facade = null;
     this.behaviour = new Behaviour();
     this.serialize_widgets = true;
   }
 
   GestureNode.prototype.onGestureChanged = function(v){
     var that = this;
     that.properties.gesture = v;
     var idx = that.gesture_list.findIndex(v);
     that.properties.gesture_interface = that.gesture_interface[idx];
   }
 
   GestureNode.prototype.onDeselected = function(){
     var parent = this.getInputNode(0);
     if(parent)
       parent.onDeselected();
   }
  
   GestureNode.prototype.tick = function(agent, dt){
     if(this.facade == null)
       this.facade = this.graph.context.facade;
 
     if(this.action){
       this.description = 'Gesture Node: ' + this.title;
       this.action(agent);
     }
     this.graph.evaluation_behaviours.push(this.behaviour);
     return this.behaviour;
   }
 
   GestureNode.prototype.action = function(){
     var behaviour = this.properties;
     this.behaviour.type = B_TYPE.gestureNode;
     this.behaviour.setData(behaviour);
   }
 
   GestureNode.prototype.onExecute = function(){
     if(this.inputs.length>1){
       for(var i in this.inputs){
         var input = this.inputs[i];
         var idx = this.findInputSlot(input.name);
         switch(input.name){
           case "intensity":
             var value = this.getInputData(idx);
             this.properties.intensity = value;
             break;
           case "duration":
             var value = this.getInputData(idx);
             value = value.toLowerCase();
             if(value == "short-term" || value == "long-term")
               this.properties.duration = value;
                       break;
                   case "gesture":
                       var value = this.getInputData(idx);
                       if(value){
                           value = value[0];
                           for(var j in this.properties){
                               if(value[j])
                                   this.properties[j] = value[j];
                               if(value.properties && value.properties[j])
                                   this.properties[j] = value.properties[j];
                           }
                           this.widgets[0].value = this.properties.interface;
                           this.widgets[1].value = this.properties.duration;
                           this.widgets[2].value = this.properties.keywords;
                       }
                       break;
                   case "coords":
                       var value = this.getInputData(idx);
                       this.properties.controller = value;
                       break;
                   case "speed":
                       var value = this.getInputData(idx);
                       this.properties.speed = value;
                       break;
         }
       }
     }
   }
 
   GestureNode.prototype.onGetInputs =  function(){
     //this.horizontal = false;
     return [["intensity", "number", {dir:LiteGraph.LEFT, pos: [0, this.size[1]]}], ["duration", "string", {dir:LiteGraph.LEFT,  pos: [0, this.size[1]]}], ["coords", "array", {dir:LiteGraph.LEFT, pos: [0, this.size[1]]}], ["array", "number", {dir:LiteGraph.LEFT, pos: [0, this.size[1]]}], ["gesture", "*", {dir:LiteGraph.LEFT, pos: [0, this.size[1]]}]];
   }
 
   GestureNode.prototype.onInputAdded = function(v){
     if(v.name == "intensity" || v.name == "duration" || v.name == "position" || v.name == "gesture"){
       //this.addInput(v.name, v.type, {dir:LiteGraph.LEFT});
       var y = this.size[1];
       v.pos[1] = y+(this.inputs.length-2)*20;
       this.size[1] = v.pos[1]+10;
     }
 
   }
 
   LiteGraph.GestureNode = GestureNode;
   LiteGraph.registerNodeType("btree/GestureNode", GestureNode);
 
   /**
   * GestureMap (Not fully implemented)
   * This node returns a B_TYPE.gestureNode Behaviour with BML formatted gesture information
   * Deprecated, use Intent/TimelineIntent instead
   */
   function GestureMap(){
       this.shape = 2;
     this.color = "#342331"
       this.bgcolor = "#523456";
     this.boxcolor = "#999";
     var w = 200;
       //this.addInput("","path", {pos:[w*0.5,-LiteGraph.NODE_TITLE_HEIGHT], dir:LiteGraph.UP});
       this.size = [160,55];
       this.editable = { property:"value", type:"number" };
       this.widgets_up = true;
     //this.horizontal = true;
 
     //this.gesture_list = ["Smile","Frown","Pout", "Pursed Lips", "Jaw Dropped", "Tongue Out", "Raise Eyebrow"];
     //this.gesture_interface = ["smile_face","frown_face","pout_face", "pursed_lips", "jaw_dropped", "tongue_out", "raise_eyebrow"];
 
     this.facade = null;
 
       this.serialize_widgets = true;
       this.addOutput("gestures", "array");
   }
 
   GestureMap.prototype.onExecute = function(){
     this.setOutputData(0, GestureManager.gestures);
   }
 
   LiteGraph.GestureMap = GestureMap;
   LiteGraph.registerNodeType("btree/GestureMap", GestureMap);
 
   /**
   * CustomRequest
   * Returns a B_TYPE.request with specified type and parameters
   */
   function CustomRequest(){
       this.shape = 2;
       this.color = "#907300";
       this.bgcolor = '#796B31';
       this.boxcolor = "#999";
       var w = 210;
       var h = 55;
 
       this.addInput("","path",{pos: [w*0.5, -LiteGraph.NODE_TITLE_HEIGHT], dir: LiteGraph.UP});
 
       //Properties
       this.properties = {type: "", parameters: {}};
 
       var that = this;
       this._typeWidget = this.addWidget("text", "Type", this.properties.type, function(v){ that.properties.type = v; });
 
           this.size = [w, h];
 
       this._node = null;
           this._component = null;
           this.serialize_widgets = true;
 
       this.behaviour = new Behaviour();
   }
 
   //Update values from inputs, if any
   CustomRequest.prototype.onExecute = function(){
       var parameters = this.properties.parameters;
       for(var i in this.inputs){
           var input = this.inputs[i];
           if(input.type != "path"){
               var value = this.getInputData(i);
               if(value !== undefined){
                   if(value.constructor === Object) value = JSON.stringify(value);
                   else if(value.constructor !== String) value = value.toString();
                   parameters[input.name] = value;
               }
           }
       }
   }
 
   CustomRequest.prototype.tick = function(agent, dt, info){
     this.behaviour.type = B_TYPE.request;
 
     var parameters = Object.assign({}, this.properties.parameters); //Clone so changes on values if there is any tag doesn't change original one
     
     for(var p in parameters){
         var value = parameters[p];
         if(info){
             if(info.tags && value.constructor === String && value[0] == "#"){ //Try to match a tag from info
                 if(info.tags[value]){
                     parameters[p] = info.tags[value];
                 }
             }else if(info[p]!=undefined){
                 parameters[p] = info[p];
             }
         }
         if(UTILS.isTag(p))
         {
             var blackboard = this.graph.context.blackboard;
             var keys = Object.keys(blackboard);
             for(var i in keys)
             {
                 var key = keys[i];
                 if(!blackboard[key])
                     continue;
                 var properties =  {};
                 if(blackboard[key].properties)
                     properties = Object.assign({},blackboard[key].properties);
                 else
                     properties = Object.assign({},blackboard[key]);
                 if(this.findProperty(parameters, p, properties ))
                     break;
                 
             }
         }
     }
     
     this.behaviour.setData({type: this.properties.type, parameters: parameters});
     this.behaviour.STATUS = STATUS.success;
     this.graph.evaluation_behaviours.push(this.behaviour);
     return this.behaviour;
 }
 CustomRequest.prototype.findProperty = function(body, p, obj) 
 {
     var value = body[p]
     for(var prop in obj)
     {    
         if(!obj[prop]) continue;
         if(obj[prop].constructor == Object)
         {
             var found = this.findProperty(body, p, obj[prop] )
            if(found) return true;
         }
         else if(p == prop)
         {
             body[p] = obj[p];
             return true;
         }
        
     } 
     return false;  
 }
 
   CustomRequest.prototype.onGetInputs = function(){
       var inputs = [];
       var parameters = this.properties.parameters;
       for(var p in parameters){
           var added = false;
           for(var i of this.inputs){
               if(i.name == p) added = true;
           }
           if(!added) inputs.push([p, "", {dir:LiteGraph.LEFT}]);
       }
       return inputs;
   }
 
   CustomRequest.prototype.addParameter = function(name, value){
       var parameters = this.properties.parameters;
       if(!name || name.constructor !== String) return false;
       if(parameters[name]) return false; //Name already used
 
       parameters[name] = value || "";
       return true;
   }
 
   LiteGraph.registerNodeType("events/CustomRequest", CustomRequest);
 
   /**
   * HttpRequest
   * Returns a B_TYPE.http_request with specified type and parameters
   */
   function HttpRequest() 
   {
     this.shape = 2;
     this.color = "#2c3394";
     this.bgcolor = "#6969aa";
     this.boxcolor = "#999";
     var w = 210;
     var h = 80;
 
     //Properties
     this.properties = {
         "method": "GET", 
         "url": "",
         "dataType": "text",
         "mimeType": "",
         "async": true
     };
 
     this.headers = {
         "Cache-Control": "no-cache",
         "apikey": ""
     };
 
     this.data = {};
 
     var that = this;
     this.methods = [
         "GET",
         "HEAD",
         "POST",
         "PUT",
         "DELETE",
         "CONNECT",
         "OPTIONS",
         "TRACE",
         "PATCH",
     ];
 
     this.dataTypes = [
         "",
         "text",
         "json",
         "arraybuffer",
         "document",
         "blob",
         "ms-stream"
     ];
 
     this.size = [w,h];
 
     this.addInput("","path",{pos: [w*0.5, -LiteGraph.NODE_TITLE_HEIGHT], dir: LiteGraph.UP});
     this.addOutput("","path", { pos:[w*0.5, h] , dir:LiteGraph.DOWN});
 
     this._methodWidget = this.addWidget("combo", "Method", this.properties.method, function(v){ that.properties.method = v; }, { values: this.methods });
     this._dataTypeWidget = this.addWidget("combo", "Data type", this.properties.dataType, function(v){ that.properties.dataType = v; },  {values: this.dataTypes});
     
     this._node = null;
     this._component = null;
     this.serialize_widgets = true;
     this.widgets_up = true;
 
     this.behaviour = new Behaviour();
     this.behaviour.type = B_TYPE.http_request;
     this.behaviour.STATUS.fail;
 
     this.response = null;
   }
 
   HttpRequest.prototype.onConfigure = function(o)
   {
     if(o.imported_templates)
         HttpRequest.Imported_Templates = o.imported_templates;
 
     this.headers = Object.assign({}, o.headers);
     this.properties = Object.assign({}, o.properties);
   }
 
   HttpRequest.prototype.onSerialize = function(o)
   {
     if(this.headers)
         o.headers = this.headers;
     if(this.data)
         o.data = this.data;
 
     if(Object.keys(HttpRequest.Imported_Templates).length)
         o.imported_templates = HttpRequest.Imported_Templates;
   }
 
   //Update values from inputs, if any
   HttpRequest.prototype.onExecute = function()
   {
     for(var i in this.inputs){
       var input = this.inputs[i];
       // if(input.type == "path")
       // continue;
       
       var value = this.getInputData(i);
 
       if(!value)
       continue;
 
       if(value.constructor === Object) 
           value = JSON.stringify(value);
       else if(value.constructor !== String) 
           value = value.toString();
       this.properties[input.name] = value;
     }
   }
 
   HttpRequest.prototype.isTag = function(value)
   {
       return value.constructor === String && value.length && value[0] == "#";
   }
 
   HttpRequest.prototype.tick = function(agent, dt, info)
   {
     if(!this.graph.context.isRunningNode(this))
     {
         var body = JSON.parse(JSON.stringify(this.data)); 
         var bb = this.graph.context.blackboard;
         this.findPlaceholders(body, info, bb)
         var requestParams = {
             "parameters": this.properties,
             "headers": this.headers,
             "data": body
         };
         this.send( Object.assign({}, requestParams), agent, dt);
     }
         
     if(this.response) {
         var b = this.response.behaviour;
         if(!b)
         {
             delete this.response;
             return;
         }
             
         // More than one behaviour
         if(b.data && b.data.constructor == Array){
             for(var _b of b.data){
                 this.graph.evaluation_behaviours.push(_b);
             }
         }else{
             this.graph.evaluation_behaviours.push(b);
         }
 
         this.graph.context.removeRunningNode(this);
         delete this.response;
         return b;
     }else{
         return this.graph.context.addRunningNode(this);
     }
   }
   HttpRequest.prototype.findPlaceholders = function(body, info, blackboard) 
   {
     for(var p in body) {
         var value = body[p];
         if(value.constructor == Object || value.constructor == Array)
             this.findPlaceholders(body[p], info, blackboard);
         if(info && info.tags) {
             // Try to match a tag from info
             if(this.isTag(body[p])&& info.tags[value]){ 
                 body[p] = info.tags[value];
                 continue;
             }
             else if(info[p] != undefined){
                 body[p] = info[p];
                 continue;
             }
         }
       
         var keys = Object.keys(blackboard);
         for(var i in keys)
         {
             var key = keys[i];
             if(!blackboard[key])
                 continue;
             var properties =  {};
             if(blackboard[key].properties)
                 properties = Object.assign({},blackboard[key].properties);
             else
                 properties = Object.assign({},blackboard[key]);
             this.findProperty(body, p, properties )
             
         } 
     }
 
   }
   HttpRequest.prototype.findProperty = function(body, p, obj) 
   {
     var value = body[p]
     for(var prop in obj)
     {    
         if(!obj[prop]) continue;
         if(obj[prop].constructor == Object)
         {
             var found = this.findProperty(body, p, obj[prop] )
           if(found) return true;
         }
         else if(this.isTag(value) && value == prop)
         {
             body[p] = obj[value];
             return true;
         }
       
     } 
     return false;  
   }
 
 
   HttpRequest.prototype.send = function(params, agent, dt) {
 
     var that = this;
 
     params.onload = function(request, parameters) {
 
         var response = {
             response: request.response, 
             behaviour: null
         };;
 
         var info = {tags: null, data: {
             req: request,
             params: parameters
         }};
         var children = that.getOutputNodes(0);
 
         //Just in case the conditional is used inside a sequencer to accomplish several conditions at the same time
         if(!children || children.length == 0){
             that.behaviour.type = B_TYPE.http_request;
             that.behaviour.STATUS = STATUS.success;
             that.response = Object.assign({}, response);
             return;
         }
 
         for(let n in children){
             var child = children[n];
             var value = child.tick(agent, dt, info);
             if(value && value.STATUS == STATUS.success){
                 agent.evaluation_trace.push(that.id);
                 /* MEDUSA Editor stuff, not part of the core */
                 if(agent.is_selected)
                     highlightLink(that, child);
 
                 that.response = Object.assign({}, response);
                 that.response.behaviour = value;
                 return;
             }
         }
               
         if(that.running_node_in_banch)
             agent.bt_info.running_node_index = null;
 
         that.behaviour.STATUS = STATUS.fail;
         that.response = Object.assign({}, response);
     }
     
     // Do http request here
     UTILS.request(params);
   }
 
   HttpRequest.prototype.onStart = HttpRequest.prototype.onDeselected = function()
   {
     var children = this.getOutputNodes(0);
     if(!children) return;
     children.sort(function(a,b){
       if(a.pos[0] > b.pos[0])
         return 1;
       if(a.pos[0] < b.pos[0])
         return -1;
     });
 
     this.outputs[0].links = [];
     for(var i in children)
       this.outputs[0].links.push(children[i].inputs[0].link);
   }
 
   HttpRequest.prototype.onGetInputs = function()
   {
     var inputs = [];
 
     for(var p in this.properties){
         var added = false;
         for(var i of this.inputs){
             if(i.name == p) added = true;
         }
         if(!added) inputs.push([p, "", {dir:LiteGraph.LEFT}]);
     }
     for(var p in this.data){
         for(var i of this.inputs){
             if(i.name == p) added = true;
         }
         if(!added) inputs.push([p, "", {dir:LiteGraph.LEFT}]);
     }
     return inputs;
   }
 
   HttpRequest.prototype.onGetOutputs = function()
   {
     var node_outputs = ["response"];
     var outputs = [];
 
     for(var i = 0; i < node_outputs.length; ++i){
         var added = false;
         for(var output of this.outputs){
             if(output.name == node_outputs[i]) added = true;
         }
         if(!added) outputs.push([node_outputs[i], "", {dir:LiteGraph.LEFT}]);
     }
 
     return outputs;
   }
 
   HttpRequest.prototype.addProperty = function(name, value, is_header)
   {
     if(!name || name.constructor !== String) return false;
 
     var container = is_header ? this.headers : this.properties;
     
     if(container[name]) return false; //Name already used
 
     container[name] = value || "";
 
     // process special cases
     this.propagate(name, container[name]);
 
     return true;
   }
 
   HttpRequest.prototype.propagate = function(name, value)
   {
     var special_cases = ["#apikey"]//, "url"];
 
     if(special_cases.indexOf(name) < 0)
     return;
 
     var nodes = this.graph.findNodesByClass(HttpRequest);
 
     for(var i = 0; i < nodes.length; ++i) {
         nodes[i].properties[name] = value;
     }
 
     return true;
   }
 
   HttpRequest.getTemplate = function(name, template_list)
   {
     template_list = template_list || HttpRequest.RAO_Templates;
     return JSON.parse(JSON.stringify(template_list[name]));
   }
 
   HttpRequest.Imported_Templates = {
 
   };
 
   HttpRequest.RAO_Templates = {
 
       "/aidocreader": {
           "api-version": "v1.0",
           "request-id": "AX0001",
           "front": {
             "image-id": "0001",
             "description": "cid-42488231-front.jpg",
             "doc-types": [
               "ITA",
               "DRIVER LICENSE"
             ],
             "content": "iVBORw0KGgo...AANSUhEUgAA==",
             "comparison-text": {
               "<label-name>": "ROSSI"
             }
           },
           "back": {
             "image-id": "0001",
             "description": "cid-42488231-front.jpg",
             "doc-types": [
               "ITA",
               "DRIVER LICENSE"
             ],
             "content": "iVBORw0KGgo...AANSUhEUgAA==",
             "comparison-text": {
               "<label-name>": "ROSSI"
             }
           },
           "options": "string"
       },
       "/facematching": {
           "api-version": "v1.0",
           "request-id": "AX0001",
           "images": [
               {
               "image-id": "0001",
               "description": "cid-42488231-front.jpg",
               "identity-id": "user01",
               "content": "iVBORw0KGgo...AANSUhEUgAA=="
               }
           ],
           "options": {
               "<option-name>": "True"
           }
       },
       "/sendotp": {
           "api-version": "v1.0",
           "request-id": "AX0001",
           "sms-text": "This is the One Time Password generated: #OTP",
           "mobile-number": "3933300112233"
       },
       "/sendsms": {
           "api-version": "v1.0",
           "request-id": "AX0001",
           "sms-text": "This is the message to the user mobile phone",
           "mobile-number": "#PhoneNumber"
       }
   }
 
   LiteGraph.registerNodeType("btree/HttpRequest", HttpRequest);
 
   /**
   * HttpResponse
   * Compare the HTTPresponse code. If there is a match it continues execution to the child nodes.
   */
   HttpResponse.CODES = [200, 201, 400];
 
   function HttpResponse(){
     this.shape = 2;
     this.color = "#2c3394";
     this.bgcolor = "#6969aa";
     this.boxcolor = "#999";
     var w = 210;
     var h = 40;
 
     //Properties
     this.properties = {
         "code": 200
     };
 
     this.data = {};
     this.size = [w,h];
 
     this.addInput("","path", { pos:[w*0.5, - LiteGraph.NODE_TITLE_HEIGHT], dir:LiteGraph.UP});
     this.addOutput("","path", { pos:[w*0.5, h] , dir:LiteGraph.DOWN});
 
     this.widgets_up = true;
     
     var that = this;
     this._codeWidget = this.addWidget("combo", "Code", this.properties.code, function(v){ that.properties.code = v; },  {values: HttpResponse.CODES});
     
     this._node = null;
     this._component = null;
     this.serialize_widgets = true;
     this.widgets_up = true;
 
     this.behaviour = new Behaviour();
     this.behaviour.type = B_TYPE.http_response;
   }
 
   HttpResponse.prototype.onConfigure = function(o)
   {
     if(o.imported_templates)
         HttpResponse.Imported_Templates = o.imported_templates;
 
     this.properties = Object.assign({}, o.properties);
   }
 
   HttpResponse.prototype.onSerialize = function(o)
   {
     if(this.data)
         o.data = this.data;
 
     if(Object.keys(HttpResponse.Imported_Templates).length)
         o.imported_templates = HttpResponse.Imported_Templates;
   }
 
   HttpResponse.prototype.tick = function(agent, dt, info) {
   
     if(!info || !info.data) {
       this.behaviour.STATUS = STATUS.fail;
       return this.behaviour;
     }
 
     var response = this.parseResponse(info.data);
     response = this.extractData(response);
     
     console.log(response);    
     // ...
     if(response.status == this.properties.code){
         var info = {data: response.data}
         //this.description = this.properties.property_to_compare + ' property passes the threshold';
         if(this.outputs)
             {
                 for(var o in this.outputs){
                     var output = this.outputs[o];
                     if(output.name == "")
                         continue;
                     if(output.dataPath){
                         var path = output.dataPath.join(".");
                         var dd = Object.byString(response.data, path)
                         if(dd!=undefined && dd[output.name]!=undefined){    
                             this.setOutputData(o, dd[output.name]);
                             continue;
                     }
                 
                 }
                     this.setOutputsFromObject(response.data, output,o)
                     
                 }
             }
         var children = this.getOutputNodes(0);
         //Just in case the conditional is used inside a sequencer to accomplish several conditions at the same time
         if(children.length == 0){
             this.behaviour.type = B_TYPE.http_response;
             this.behaviour.STATUS = STATUS.success;
             return this.behaviour;
         }
         
         
         for(let n in children){
             var child = children[n];
             var value = child.tick(agent, dt, info);
             if(value && value.STATUS == STATUS.success){
                 agent.evaluation_trace.push(this.id);
                 /* MEDUSA Editor stuff, not part of the core */
                 if(agent.is_selected)
                     highlightLink(this, child);
 
                 
                 return value;
             }
             else if(value && value.STATUS == STATUS.running){
                 agent.evaluation_trace.push(this.id);
                 /* MEDUSA Editor stuff, not part of the core */
                 if(agent.is_selected)
                     highlightLink(this, child)
 
                 return value;
             }
         }
     }
     if(this.running_node_in_banch)
             agent.bt_info.running_node_index = null;
 
     this.behaviour.STATUS = STATUS.fail;
     return this.behaviour;
     /*this.behaviour.STATUS = response ? STATUS.success : STATUS.fail;
     return this.behaviour;*/
   }
 
   HttpResponse.prototype.parseResponse = function (data) {
       
     if(!data.req || !data.params)
         return null;
 
     var xhr = data.req;
     var params = data.params;
 
     // Check control code
     if(xhr.status != this.properties["code"])
         return null;
 
     var response = xhr.response;
 
     function __validate() {
 
         if(params.dataType == "json") {
             try  {
                 response = JSON.parse(response);
             }
             catch (err) {
                 // throw err;
             }
         }
         else if(params.dataType == "xml") {
             try {
                 var xmlparser = new DOMParser();
                 response = xmlparser.parseFromString(response,"text/xml");
             }
             catch (err) {
                 // throw err;
             }
         }
     }
 
     switch(xhr.status) {
         case 200:
             __validate();
             break;
         default:
             console.warn("HttpRequest Error", xhr);
             break;
     }
 
     return { status : xhr.status, data : response};
   }
 
   HttpResponse.prototype.extractData = function (response) {
 
     var res = response.data;
 
     function __evaluate(r, d){
       for(var k in r){
         if(!d[k])
             delete r[k];
         else{
             if(r[k].constructor == Object)
                 return __evaluate(r[k], d[k]);
             else
                 return r[k];
         }           
       }
     }
     if(this.data || this.data != {}){
       for(var k in res){
         if(!this.data[k])
             delete res[k];
         else{
             if(res[k].constructor == Object)
                 res[k] = __evaluate(res[k], this.data[k]);
         }
       }
     }
 
     response.data = res;
     return response;
   }
 
   HttpResponse.prototype.onDeselected = function () {
     var parent = this.getInputNode(0);
     if(parent)
       parent.onDeselected();
   }
 
   HttpResponse.prototype.onShowNodePanel = function( event, pos, graphcanvas ){
     return true; //return true is the event was used by your node, to block other behaviours
   }
 
   HttpResponse.getTemplate = HttpRequest.getTemplate;
 
   HttpResponse.Imported_Templates = {
 
   };
 
   HttpResponse.RAO_Templates = {
 
       
   }
   HttpResponse.prototype.onGetOutputs = function(){
     var outputs = [];
     this.addOutputsFromObject(this.data, outputs, []) 
     return outputs;
   }
   HttpResponse.prototype.addOutputsFromObject = function(data, outputs, path) 
   {  
     for(var i in data)
     {
       if(data[i].constructor == Array || data[i].constructor == Object)
       {
         var p = [...path];
         p.push(i)
         this.addOutputsFromObject(data[i], outputs, p)      
       }
       else
       {
         outputs.push([i, typeof(data[i]), {"dataPath":path}]);
       }  
     }
   }
   HttpResponse.prototype.setOutputsFromObject = function(data, output, o) 
   {
     for(var i in data)
     {
       if(data[output.name]!=undefined)
       {
         this.setOutputData(o, data[output.name]);
         continue;
       }
       else if(data[i]!=undefined && (data[i].constructor == Array || data[i].constructor == Object))
         this.setOutputsFromObject(data[i], output, o)        
     }
   }
   LiteGraph.registerNodeType("btree/HttpResponse", HttpResponse );
 
  
   //lack of type choice --> on progress
   function SetProperty()
   {
     this.shape = 2;
     this.color = "#2e542e"
     this.bgcolor = "#496b49";
     this.boxcolor = "#999";
     this.size = [200,80];
     this.addInput("","path", {pos:[200*0.5,-LiteGraph.NODE_TITLE_HEIGHT], dir:LiteGraph.UP});
     this.addInput("name","", {pos:[0,35], dir:LiteGraph.LEFT});
     this.addInput("root","", {pos:[0,55], dir:LiteGraph.LEFT});
     this.addProperty("priority", "append", "enum", {
         values: [
             "append",
             "overwrite",
             "mix",
             "skip"
         ]
     });
     this.addProperty("value", 1.0, "number");
     this.addProperty("property_to_compare", "", "string");
     this.addProperty("on", "execute", "enum", {values: ["tick", "execute"]})
     this.editable = { property:"value", type:"number" };
     this.widgets_up = true;
     this.horizontal = true;     
     var that = this;
     this.dynamic = null;
     this.widget_type = "number";
     this.target_type = "agent";
     this.dynamic = this.addWidget("string","name", "", function(v){ that.properties.property_to_compare = v; }, this.properties );
     this.dynamic = this.addWidget("string","value", 5, function(v){ that.properties.value = v; }, this.properties );
     this.tmp_data = {};
     this.facade = null;
     this.behaviour = new Behaviour();
     this.serialize_widgets = true;
 
   }
   SetProperty.prototype.onExecute = function()
   {
     var data = this.getInputData(1);
     var root = this.getInputData(2);
     if(data)
         this.properties.property_to_compare = data;
     
     if(!this.graph.character_evaluated) return;
     /*if(this.graph.character_evaluated.properties[data])
     {	
       this.target_type = "agent";
     }
     else if(blackboard[data])
     {
       this.target_type = "global";
     }*/
     if(this.inputs.length==4)
     {
       var value = this.getInputData(3);
       this.properties.value = value;    
     }
     this.target_type = root;
   }
   SetProperty.prototype.onGetInputs = function()
   {
     this.size[1] +=30;
     return [["value", "",{dir:LiteGraph.LEFT, pos: [0, this.size[1]-30]}]];
   }
 
   SetProperty.prototype.tick = function(agent, dt)
   {
     if(this.properties.on == "tick")
     {
         this.onExecute();
     }
     if(this.facade == null)
       this.facade = this.graph.context.facade;
 
     agent.evaluation_trace.push(this.id);
     // the property has to increment or decrement
     if(this.properties.value.constructor == Array && (this.properties.value[0] == "-" || this.properties.value[0] == "+"))
     {
       if(this.target_type == "agent")
       {
         var f_value = this.facade.getEntityPropertyValue(this.properties.property_to_compare, agent);
         f_value += parseFloat(this.properties.value);
         this.tmp_data = {type:"setProperty", name: this.properties.property_to_compare, value:f_value}
       }
       else
         this.tmp_data = {type:"setProperty", name: this.properties.property_to_compare, value:this.properties.value}
     }
     //just set the property to the value
     else{
       var final_value = this.properties.value;
       if(this.properties.value == "true" || this.properties.value == "false")
       {
         final_value = this.properties.value == "true" ? true : false;
       }
       else if(!isNaN(parseFloat(this.properties.value)))
         final_value = parseFloat(this.properties.value);
 
 
       if(this.target_type == "agent")
       {
         this.tmp_data = {type:"setProperty", name: this.properties.property_to_compare, value:final_value, type: this.target_type}
       }
       else
         this.tmp_data = {type:"setProperty", name: this.properties.property_to_compare, value:final_value, type: this.target_type}
     }
 
     this.behaviour.type = B_TYPE.setProperty;
     this.behaviour.setData(this.tmp_data);
     this.behaviour.STATUS = STATUS.success; 
     this.behaviour.priority = this.properties.priority; 
     this.graph.evaluation_behaviours.push(this.behaviour);
     return this.behaviour;
   }
 
   LiteGraph.registerNodeType("btree/SetProperty", SetProperty);
   //-----------------------BASIC NODES------------------------------------//
   /**
   * Property
   * Returns the value of the specified property
   */
   //TODO standardize so it takes values from the same place, not hardcoded
   function Property(){
     this.shape = 2;
     this.color = "#907300";
     this.bgcolor = '#796B31';
     this.boxcolor = "#999";
     var w = 210;
     var h = 55;
     this.addInput("value","");
 
     this.flags = {};
     this.properties = {value:null, node_name: this.title, type:"float", property_type: this.property_type};
     this.data = {};
     this.size = [w, h];
     var that = this;
 
     this.property_type = "agent" ;
 
     this._node = null;
     this._component = null;
     this.serialize_widgets = true;
   }
 
   Property.prototype.onExecute = function(){
     //Check if its Scene or Agent
     var value = this.getInputData(0);
     var entity;
     var property_type = this.property_type.split("/");
     switch(property_type[0]){
       case "agent":
         entity = currentHBTGraph.graph.character_evaluated;
           break;
       case "user":
         entity = currentHBTGraph.graph.context.user;
           break;
       case "gesture-property":
         entity = GestureManager.gestures[property_type[1]];
           break;
     }
 
       currentHBTGraph.graph.context.facade.setEntityProperty(entity,this.title,value);
   }
 
   /* ADDED BY EVA */
   Property.prototype.onSerialize = function(o){
     if(this.property_type){
       o.property_type = this.property_type;
     }
   }
 
   LiteGraph.registerNodeType("basic/property", Property);
 
   function ToObjectData(){
     this.addInput("name", "string");
     this.addInput("value", "");
     this.addOutput("obj", "object");
   }
 
   ToObjectData.prototype.onExecute = function (){
     var name = this.getInputData(0);
     var value = this.getInputData(1);
     var obj = {};
     obj[name] = value;
     this.setOutputData(0, obj)
   }
 
   LiteGraph.registerNodeType("basic/to_object", ToObjectData);
 
   function JSONstringify(){
     this.addInput("obj", "object");
     this.addOutput("string", "string");
   }
 
   JSONstringify.prototype.onExecute = function(){
     var obj = this.getInputData(0) || {};
     this.setOutputData(0, JSON.stringify(obj))
   }
 
   LiteGraph.registerNodeType("basic/to_json", JSONstringify);
 
   function JSONparse(){
     this.addInput("string", "string");
     this.addOutput("obj", "object");
   }
 
   JSONparse.prototype.onExecute = function(){
     var str = this.getInputData(0) || "{}";
     var obj = JSON.parse(str);
     this.setOutputData(0, obj );
   }
 
   LiteGraph.registerNodeType("basic/json_parse", JSONparse);
 
  
 
   function NodeScript() {
     this.size = [60, 30];
     this.addProperty("onExecute", "return A;");
     this.addProperty("temp_code", "");
     this.addProperty("prefab_code_key", "custom");
     this.addProperty("prefab_code_value", "");
     this.addInput("A", "");
     this.addInput("B", "");
     this.addOutput("out", "");
     this.properties.sample_codes = {
         custom:"",
         string_to_date: `var today = new Date();
         var birthDate = new Date(A);
         var age = today.getFullYear() - birthDate.getFullYear();
         var m = today.getMonth() - birthDate.getMonth();
         if (m < 0 || (m === 0 && today.getDate() < birthDate.getDate())) {
             age--;
         }
         return age;`, 
         count_vowels: `var m = A.match(/[aeiou]/gi);
         return m === null ? 0 : m.length;`
 
     }
     this._func = null;
     this.data = {};
   }
 
   NodeScript.prototype.onConfigure = function(o) {
       // debugger;
       if (o.properties.onExecute && LiteGraph.allow_scripts)
           this.compileCode(o.properties.onExecute);
       else
           console.warn("Script not compiled, LiteGraph.allow_scripts is false");
   };
 
   NodeScript.title = "ScriptNode";
   NodeScript.desc = "executes a code (max 512 characters)";
 
   NodeScript.widgets_info = {
       onExecute: { type: "code" }
   };
 
   NodeScript.prototype.onPropertyChanged = function(name, value) {
     if (name == "onExecute" && LiteGraph.allow_scripts)
         this.compileCode(value);
     else
         console.warn("Script not compiled, LiteGraph.allow_scripts is false");
   };
 
   NodeScript.prototype.compileCode = function(code) {
     this._func = null;
     if (code.length > 1024) {
         console.warn("Script too long, max 256 chars");
     } else {
         var code_low = code.toLowerCase();
         var forbidden_words = [
             "script",
             "body",
             "document",
             "eval",
             "nodescript",
             "function"
         ]; //bad security solution
         for (var i = 0; i < forbidden_words.length; ++i) {
             if (code_low.indexOf(forbidden_words[i]) != -1) {
                 console.warn("invalid script");
                 return;
             }
         }
         try {
             this._func = new Function("A", "B", "C", "DATA", "node", code);
             console.log("FUNCION ADDED");
         } catch (err) {
             console.error("Error parsing script");
             console.error(err);
         }
     }
   };
 
   NodeScript.prototype.onExecute = function() {
     if (!this._func) {
         return;
     }
 
     try {
         var A = this.getInputData(0);
         var B = this.getInputData(1);
         var C = this.getInputData(2);
         this.setOutputData(0, this._func(A, B, C, this.data, this));
     } catch (err) {
         console.error("Error in script");
         console.error(err);
     }
   };
 
   NodeScript.prototype.onGetOutputs = function() {
     return [["C", ""]];
   };
 
 
   LiteGraph.registerNodeType("basic/script", NodeScript);
 
 
   function TriggerSubtree()
   {
     this.shape = 2;
     this.color = "#1E1E1E"
     this.boxcolor = "#999";
     var w = 150;
     var h= 40;
 
     this.properties = {target_id:null};
     this.addProperty("target_id", "");
     
     this.addInput("","path", {pos:[w*0.5,-LiteGraph.NODE_TITLE_HEIGHT], dir:LiteGraph.UP});
     var that = this;
     this.widget = this.addWidget("string","target_id", this.properties.target_id, function(v){v = v.replace("Event ", ""); that.properties.target_id = v;});
 
     this.widgets_up = true;
     this.size = [w,h];
     this.serialize_widgets = true;
     this.behaviour = new Behaviour();
       
   }
 
   TriggerSubtree.prototype.tick = function(agent, dt, info)
   {
     var child = this.graph.getNodeById(this.properties.target_id);
     if(!child)
     {
         var obj = {STATUS:STATUS.fail}
         return obj;
     }
     this.graph.context.last_event_node = null; 
     var value = child.tick(agent, dt);
 
     if(value && (value.STATUS == STATUS.running || value.STATUS == STATUS.success))
     {
         agent.evaluation_trace.push(this.id);
         this.behaviour.STATUS = STATUS.success;
         //Editor stuff [highlight trace]
         if(agent.is_selected)
             highlightLink(this, child);
         return value;
     } 
     if(this.behaviour.STATUS == STATUS.fail)
         return value;
     
   }
 
   TriggerSubtree.prototype.onConfigure = function(info){
     onConfig(info, this.graph);
   }
 
   LiteGraph.registerNodeType("btree/TriggerSubtree", TriggerSubtree);
 
   function SubRoot()
   {
     this.shape = 2;
     this.color = "#1E1E1E"
     this.boxcolor = "#999";
     this.addOutput("","path");
     this.properties = {};
     this.horizontal = true;
     this.widgets_up = true;
 
     this.behaviour = new Behaviour();
   }
   SubRoot.prototype.onAdded = function(){
     this.title = "SubRoot "+this.id;
   }
 
   SubRoot.prototype.tick = function(agent, dt)
   {
     var children = this.getOutputNodes(0);
     for(var n in children)
     {
       var child = children[n];
       // if(child.constructor.name == "Subgraph")
       // 	child = child.subgraph.findNodeByTitle("HBTreeInput");
       var value = child.tick(agent, dt);
       if(value && (value.STATUS == STATUS.success || value.STATUS == STATUS.running))
       {
         if(agent.is_selected)
           highlightLink(this, child)
         //push the node_id to the evaluation trace
         agent.evaluation_trace.push(this.id);
 
         //know if bt_info params must be reset
         //if the node was not in the previous 
         // if(!nodePreviouslyEvaluated(agent, this.id))
         // 	resetHBTreeProperties(agent)
 
         return value;
       }
     }
 
     // if(this.running_node_in_banch)
     // 	agent.bt_info.running_node_index = null;
 
     this.behaviour.STATUS = STATUS.fail;
     return this.behaviour;
   }
 
   SubRoot.prototype.onConfigure = function(info)
   {
     onConfig(info, this.graph);
     this.graph.root_node =  this;
   }
 
   // SubRoot.title = "Root";
   // SubRoot.desc = "Start node of the Hybrid Behaviour Tree";
 
   //reorder the links
   SubRoot.prototype.onStart = SubRoot.prototype.onDeselected = function()
   {
     var children = this.getOutputNodes(0);
     if(!children) return;
     children.sort(function(a,b)
     {
       if(a.pos[0] > b.pos[0])
         return 1;
       
       if(a.pos[0] < b.pos[0])
         return -1;
       
     });
 
     this.outputs[0].links = [];
     for(var i in children)
       this.outputs[0].links.push(children[i].inputs[0].link);
   }
 
   LiteGraph.registerNodeType("btree/SubRoot", SubRoot);
 })(this);

(function(global){
	UTILS = (global.UTILS = {
    
    /**
	* MODIFIED FROM LITEGUI.JS
	* Request file from url (it could be a binary, text, etc.). If you want a simplied version use
	* @method request
	* @param {Object} request object with all the parameters like data (for sending forms), dataType, success, error
	* @param {Function} on_complete
	**/
	request: function(request)
	{
		var parameters = request.parameters || {};
		var headers = request.headers || {};
		var data = request.data || null;

		var dataType = parameters.dataType || "text";
		if(dataType == "json") //parse it locally
		{
			dataType = "application/json";
			data = JSON.stringify(data);
		}
		else if(dataType == "xml") //parse it locally
			dataType = "text";
		else if (dataType == "binary")
		{
			//request.mimeType = "text/plain; charset=x-user-defined";
			dataType = "arraybuffer";
			parameters.mimeType = "application/octet-stream";
		}

		//regular case, use AJAX call
        var xhr = new XMLHttpRequest();
		var method = data ? 'POST' : 'GET';

		if(parameters.method && parameters.method.length)
			method = parameters.method;

		var asyncRequest = true;

		if(parameters.async !== undefined)
			asyncRequest = parameters.async;

        xhr.open( method, parameters.url, asyncRequest);
        /*if(dataType)
            xhr.responseType = dataType;*/
        if (parameters.mimeType)
            xhr.overrideMimeType( parameters.mimeType );

		for(var h in headers)
		{
			xhr.setRequestHeader(h, headers[h]);
		}

        xhr.onload = function(load)
		{
			if(request.onload){
				request.onload(this, parameters);
				return;
			}

			var response = this.response;
			if(this.status != 200)
			{
				var err = "Error " + this.status;
				if(request.error)
					request.error(err, response, this);
				return;
			}

			if(parameters.dataType == "json") //chrome doesnt support json format
			{
				try
				{
					response = JSON.parse(response);
				}
				catch (err)
				{
					if(request.error)
						request.error(err, response, this);
					else
						throw err;
				}
			}
			else if(parameters.dataType == "xml")
			{
				try
				{
					var xmlparser = new DOMParser();
					response = xmlparser.parseFromString(response,"text/xml");
				}
				catch (err)
				{
					if(request.error)
						request.error(err, response, this);
					else
						throw err;
				}
			}
			
			if(request.success)
				request.success.call(this, response, this);
		};

        xhr.onerror = function(err) {
			if(request.error)
				request.error(err, this);
		}

		/*var formData = new FormData();
		if( data )
		{
			for(var i in data)
				formData.append(i, data[i]);
		}*/

        xhr.send( data );
		return xhr;
	},

    arrayToString: function(array)
    {
        var str = "";
        for(var i = 0; i < array.length; i++)
            str += String.fromCharCode(array[i]);
        return str;
    },

    rand : function() {
      return Math.random().toString(36).substr(2); // remove `0.`
    },

	getLine: function(text, idx) {
		
		if(idx > text.length)
		return -1;

		var s = "";

		for (var i = 0; i < idx; i++) {
			if (text[i] === '\n')
				s = "";
			else
			s += text[i];
		}
	  
		return s;
	},

	getTabs: function(text, n) {
		var count = 0;
		var spaces = 0;

		for (var i = 0; i < text.length; i++) {
			if (text[i] === ' '){
				spaces++;

				if(spaces == n){
					count++;
					spaces = 0;
				}
			}
			else
				spaces = 0;
		}

		return count;
	},

    getFileExtension(filename) {

        var tkn = filename.split(".");
        return tkn.pop().toLowerCase();
    },

    replaceAll(str, find, replace) {
        return str.replace(new RegExp(find, 'g'), replace);
    },

    includes(str, find)
    {
        find = [].concat(find);

        for(var i = 0; i < find.length; i++)
            if( str.toLowerCase().includes(find[i]) )
                return true;
    },

	getObjectClassName(obj)
	{
		if (!obj)
			return;

		if(obj.constructor.fullname) //this is to overwrite the common name "Prefab" for a global name "ONE.Prefab"
			return obj.constructor.fullname;

		if(obj.constructor.name)
			return obj.constructor.name;

		var arr = obj.constructor.toString().match(
			/function\s*(\w+)/);

		if (arr && arr.length == 2) {
			return arr[1];
		}
	},
	isTag(value)
	{
		return value.constructor === String && value.length && value[0] == "#";
	}
    
})})